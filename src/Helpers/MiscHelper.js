import { SecurityIcon, UnknownIcon } from '@patternfly/react-icons';
import { SortByDirection } from '@patternfly/react-table';
import { useHistory, useLocation  } from 'react-router-dom';
import findIndex from 'lodash/findIndex';
import propTypes from 'prop-types';
import React from 'react';
import { impactColorList, impactList, CVSS_OPTIONS, PUBLIC_DATE_OPTIONS } from './constants';
import qs from 'query-string';

export const dataShape = propTypes.shape({
    data: propTypes.oneOfType([propTypes.object, propTypes.array]),
    meta: propTypes.object,
    isLoading: propTypes.bool
});

/**
 * Based on the  allowedParams it will construct the arguments for the API call
 * which is defined in the vulnerabilities-client. vulnerabilities-client is written is typescript
 * so we need to define and pass every single parameter. Order in allowedParams is important
 *
 * @param {Object} apiProps
 * @param {Array} allowedParams - order should align with the params in the vulnerabilities-client
 */
export function constructParameters(apiProps, allowedParams) {
    if (apiProps) {
        Object.keys(apiProps).forEach(
            key => (
                apiProps[key] === undefined
                || apiProps[key] === ''
            )
            && delete apiProps[key]
        );

        const params = allowedParams.map(item => apiProps[item]);

        return params;
    }

    return [];
}

// TODO DRY:similar to constructParameters
export function constructURLParameters(urlParams, allowedParams) {
    if (urlParams) {
        const params = { ...urlParams };
        Object.keys(urlParams).forEach(
            key => (
                params[key] === undefined
                || params[key] === ''
                || !allowedParams.includes(key)
                || params[key] === false
            )
            && delete params[key]

        );
        return params;
    }
}

export function formatDate(date = new Date()) {
    const prepend = (number) => `${`${number}`.length === 1 ? '0' : ''}${number}`;
    const toFormat = new Date(date);
    if (toFormat instanceof Date && !isNaN(toFormat)) {
        const year = toFormat.getFullYear();
        const month = toFormat.getMonth();
        const day = toFormat.getDate();
        return `${year}-${prepend(month)}-${prepend(day)}`;
    }

    return toFormat;
}

/**
 * Contructs the filters which have more than one parameter that needs to be passed
 * and resets all the parameteres when it's needed
 *
 * @param {Object} filterParams
 * @return {Object}
 */
export function constructFilterParameters(filterParams) {
    if (Object.prototype.hasOwnProperty.call(filterParams, 'cvss_filter')) {
        let cvssEntry = CVSS_OPTIONS.find(({ value }) => value === filterParams.cvss_filter);

        if (typeof cvssEntry === 'undefined' && typeof filterParams.cvss_filter !== 'undefined') {
            let values = filterParams.cvss_filter.split(/[^0-9]+/).filter(item => parseFloat(item));
            let [from, to] = values;
            cvssEntry = { from, to };
        } else if (typeof cvssEntry === 'undefined' && typeof filterParams.cvss_filter === 'undefined') {
            cvssEntry = { from: undefined, to: undefined };
        } else if ((cvssEntry && cvssEntry.label === 'N/A') && filterParams.cvss_filter === 'from-1to-1') {
            cvssEntry = { from: -1, to: -1 };
        }

        filterParams.cvss_from = cvssEntry.from;
        filterParams.cvss_to = cvssEntry.to;
    }

    if (Object.prototype.hasOwnProperty.call(filterParams, 'publish_date')) {
        let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);

        if (typeof publicEntry !== 'undefined') {
            filterParams.public_from = publicEntry.from && formatDate(publicEntry.from);
            filterParams.public_to = publicEntry.to && formatDate(publicEntry.to);
        } else {
            filterParams.public_from = undefined;
            filterParams.public_to = undefined;
            filterParams.publish_date = undefined;
        }
    }

    return filterParams;
}

export function getImpactDetails(impact) {
    if (Object.keys(impactList).includes(impact)) {
        return {
            title: impactList[impact].title,
            color: impactList[impact].color,
            text: impactList[impact].text,
            titleContent: (
                <SecurityIcon size="lg" />
            )
        };
    } else {
        return {
            title: 'Unknown',
            color: impactColorList.unknown,
            text: '',
            titleContent: (
                <UnknownIcon size="lg" />
            )
        };
    }
}

export const createSortBy = (header, value) => {
    if (value) {
        let direction = value.indexOf('-') === 0 ? SortByDirection.desc : SortByDirection.asc;
        value = value.replace(/^(-|\+)/, '');
        const index = findIndex(header, item => item.key === value);
        let sort = {
            index,
            direction
        };
        return sort;
    }

    return {};
};

export const handleSortColumn = (key, direction, header, currentSort, apply) => {
    let columnName = header[key].key;
    const useDefault = currentSort && currentSort.substr(1) !== columnName;
    if (direction === SortByDirection.desc || useDefault) {
        columnName = '-' + columnName;
    }

    apply({ sort: columnName });
};

export const updateStateSet = (stateSet, names, value) => {
    [].concat(names).forEach(name => {
        value ? stateSet.add(name) : stateSet.delete(name);
    });
    return stateSet;
};

export const useCreateUrlParams = (allowedParams) => {
    const location = useLocation();
    const history = useHistory();
    const urlParams = qs.parse(location.search);

    const createUrlParams = (parameters) => {
        history.push(`?${qs.stringify(constructURLParameters(parameters, allowedParams))}`);
    };

    return [createUrlParams, urlParams];
};
