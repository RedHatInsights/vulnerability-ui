import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { useIntl } from 'react-intl';
import {
    addNotification as addNotificationFEC,
    clearNotifications as clearNotificationsFEC
} from '@redhat-cloud-services/frontend-components-notifications/redux';
import { optOutSystemsAction } from '../../src/Store/Actions/Actions';
import messages from '../Messages';
import { NotAuthorizedNotification, ReadOnlyNotification } from './constants';
import { useState } from 'react';

export const useNotification = (config) => {
    const dispatch = useDispatch();

    const globalConfig = {
        variant: 'info',
        ...config
    };

    useEffect(() => {
        return () => {
            if (!config.preventClear) {
                dispatch(clearNotificationsFEC());
            }
        };
    }, [dispatch]);

    const addNotification = ({ msg, ...config }) =>
        dispatch(
            addNotificationFEC({
                title: msg,
                ...globalConfig,
                ...config
            })
        );

    const clearNotifications = () =>
        dispatch(clearNotificationsFEC());

    return [addNotification, clearNotifications];
};

export const useGetEntities = (fetchApi, { id, setUrlParams, createRows }) => {

    const getEntities = async (
        _items,
        { orderBy, orderDirection, page, per_page: perPage, vulnerabilityParams }
    ) => {
        const sort = `${orderDirection === 'ASC' ? '' : '-'}${orderBy}`;

        const params = {
            ...vulnerabilityParams,
            page,
            page_size: perPage,
            sort
        };

        setUrlParams?.({ ...params });

        const items = await fetchApi(
            {
                ...id && { id },
                ...params
            }
        );

        return {
            results: typeof createRows === 'function'
                ? createRows({ items, cveId: id })
                : items?.data?.map(row => ({ id: row.id, ...row.attributes })),
            total: items?.meta?.total_items,
            page: items?.meta?.page,
            perPage: items?.meta?.page_size,
            meta: {
                page: items?.meta?.page,
                sort: items?.meta?.sort,
                page_size: items?.meta?.page_size
            }
        };
    };

    return getEntities;
};

export const useOptOutSystems = onRefreshInventory => {
    const [addSuccessNotification] = useNotification({ variant: 'success' });
    const [addFailureNotification] = useNotification({ variant: 'danger', autoDismiss: false });
    const dispatch = useDispatch();
    const intl = useIntl();

    /**
     * Excludes/included provided system(s), if toggling one system systemId and systemName have to be set.
     * If toggling multiple systems, these two params are ignored and system info will be extracted from selectedRows.
     * @param {object} affectedRows - object with keys representing ids of systems to opt out/in
     * @param {?string} systemName - display name of a system if only a single system is toggled
     * @param {bool} isIncluded - if true systems will be excluded, else included
     */
    return (affectedRows, systemName, isIncluded) => {
        const count = Object.keys(affectedRows).length;

        dispatch(optOutSystemsAction(Object.keys(affectedRows), isIncluded))
            .then(() => {
                addSuccessNotification(isIncluded
                    ? {
                        msg: intl.formatMessage(messages.notificationExcludeSuccess, { count, systemName })
                    }
                    : {
                        msg: intl.formatMessage(messages.notificationIncludeSuccessTitle, { count, systemName }),
                        description: intl.formatMessage(messages.notificationIncludeSuccessBody)
                    }
                );
            }).catch(error => {
                addFailureNotification(
                    error.status === '503' ? ReadOnlyNotification :
                        error.status === '403' ? NotAuthorizedNotification :
                            isIncluded
                                ? {
                                    msg: intl.formatMessage(messages.notificationExcludeFailureTitle, { count, systemName }),
                                    description: intl.formatMessage(messages.notificationExcludeFailureBody, { count })
                                }
                                : {
                                    msg: intl.formatMessage(messages.notificationIncludeFailureTitle, { count, systemName }),
                                    description: intl.formatMessage(messages.notificationIncludeFailureBody, { count })
                                }
                );
            }).finally(onRefreshInventory);
    };
};

// Temp solution to suppoint
const mapSelectedRows = ({ id, inventory_id: inventoryId }) => ({ id: id ? id : inventoryId, selected: true });

export const useBulkSelect = ({ rawData, selectedRows, selectedRowsCount, handleSelect, fetchResource, multiRow = false }) => {
    const intl = useIntl();
    const { meta, data } = rawData;

    const selectPageNumber = data && (((Array.isArray(data) && data.length) && multiRow) ? data.length / 2 : data.length);

    const handleSelectPage = () => {
        const { data } = rawData ?? {};
        handleSelect(data?.map(mapSelectedRows));
    };

    const handleUnselect = () => {
        let toSelect = [];
        Object.keys(selectedRows).forEach((id) => {
            toSelect.push(
                {
                    id,
                    selected: false
                }
            );

            return toSelect;
        });

        handleSelect(toSelect);
    };

    const handleSelectAll = async () => {

        let { payload } = await fetchResource({ page_size: meta.totalItems, page: 1 });

        payload.then(({ data }) => handleSelect(data.map(mapSelectedRows)));
    };

    return {
        count: selectedRowsCount,
        checked: !!selectedRowsCount,
        isDisabled: meta.totalItems === 0 && selectedRowsCount === 0,
        ouiaId: 'bulk-select',
        items: [
            {
                title: intl.formatMessage(messages.selectNone),
                onClick: handleUnselect
            },
            {
                title: `${intl.formatMessage(messages.selectPage, { count: selectPageNumber })}`,
                onClick: handleSelectPage
            },
            {
                title: `${intl.formatMessage(messages.selectAll, { count: meta.totalItems })}`,
                onClick: handleSelectAll
            }
        ],
        onSelect: () => !selectedRowsCount ? handleSelectAll() : handleUnselect()
    };

};

const matchPermissions = (permissionA, permissionB) => {
    const segmentsA = permissionA.split(':');
    const segmentsB = permissionB.split(':');

    if (segmentsA.length !== segmentsB.length) {
        return false;
    }

    return segmentsA.every((segmentA, index) => segmentA === segmentsB[index] || segmentA === '*' || segmentsB[index] === '*');
};

/**
 * Checks whether user has particular permissions
 * @param {array} requestedPermissions - array of strings each represening a permission (defined in constants.js > PERMISSIONS)
 * @param app - application to get permissions for
 * @returns {array} - array where first element is an array of bools, representing each permission from parameter array,
 * second element is bool whether permissions are loading
 */
export const useRbac = (requestedPermissions, app = 'vulnerability') => {
    const [allPermissions, setAllPermissions] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(()=>{
        insights?.chrome?.getUserPermissions?.(app, true).then(permissions => {
            setAllPermissions(permissions);
            setLoading(false);
        });
    }, []);

    if (loading) {
        return [requestedPermissions.map(() => []), true];
    }

    return [requestedPermissions.map(requestedPermission =>
        allPermissions?.some(item => matchPermissions(item.permission, requestedPermission))), false];
};
