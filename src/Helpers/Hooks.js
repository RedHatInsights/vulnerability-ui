import React, { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { useIntl } from 'react-intl';
import {
    addNotification as addNotificationFEC,
    clearNotifications as clearNotificationsFEC
} from '@redhat-cloud-services/frontend-components-notifications/redux';
import { optOutSystemsAction } from '../../src/Store/Actions/Actions';
import messages from '../Messages';
import { NotAuthorizedNotification, ReadOnlyNotification } from './constants';
import { useState } from 'react';
import unionBy from 'lodash/unionBy';
import ColumnManagementModal from '../Components/SmartComponents/Modals/ColumnManagementModal';
import useChrome from '@redhat-cloud-services/frontend-components/useChrome';

export const useNotification = (config = {}) => {
    const dispatch = useDispatch();

    const globalConfig = {
        variant: 'info',
        ...config
    };

    useEffect(() => {
        return () => {
            if (!config.preventClear) {
                dispatch(clearNotificationsFEC());
            }
        };
    }, [dispatch]);

    const addNotification = ({ msg, ...config }) =>
        dispatch(
            addNotificationFEC({
                title: msg,
                ...globalConfig,
                ...config
            })
        );

    const clearNotifications = () =>
        dispatch(clearNotificationsFEC());

    return [addNotification, clearNotifications];
};

const getSortValue = (orderBy, orderDirection) => {
    // vulnerability API service uses different key to sort by groups
    return `${orderDirection === 'ASC' ? '' : '-'}${orderBy === 'group_name' ? 'inventory_group' : orderBy}`;
};

export const useGetEntities = (fetchApi, { id, setUrlParams, createRows }) => {

    const getEntities = async (
        _items,
        { orderBy, orderDirection, page, per_page: perPage, vulnerabilityParams, filters }
    ) => {
        const params = {
            ...vulnerabilityParams,
            page,
            page_size: perPage,
            sort: getSortValue(orderBy, orderDirection),
            ...filters?.hostGroupFilter ? {
                group_names: filters.hostGroupFilter.join(',')
            } : {}
        };

        setUrlParams?.({ ...params });

        const items = await fetchApi(
            {
                ...id && { id },
                ...params
            }
        );

        return {
            results: typeof createRows === 'function'
                ? createRows({ items, cveId: id })
                : items?.data?.map(row => ({ id: row.id, ...row.attributes })),
            total: items?.meta?.total_items,
            page: items?.meta?.page,
            perPage: items?.meta?.page_size,
            meta: {
                page: items?.meta?.page,
                sort: items?.meta?.sort,
                page_size: items?.meta?.page_size,
                cves_without_errata: items?.meta?.cves_without_errata
            }
        };
    };

    return getEntities;
};

export const useOptOutSystems = onRefreshInventory => {
    const [addSuccessNotification] = useNotification({ variant: 'success' });
    const [addFailureNotification] = useNotification({ variant: 'danger', autoDismiss: false });
    const dispatch = useDispatch();
    const intl = useIntl();

    /**
     * Excludes/included provided system(s), if toggling one system systemId and systemName have to be set.
     * If toggling multiple systems, these two params are ignored and system info will be extracted from selectedRows.
     * @param {object} affectedRows - array of objects of systems to opt out/in
     * @param {?string} systemName - display name of a system if only a single system is toggled
     * @param {bool} isIncluded - if true systems will be excluded, else included
     */
    return (affectedRows, systemName, isIncluded) => {
        const count = affectedRows.length;

        dispatch(optOutSystemsAction(affectedRows.map(row => row.id), isIncluded))
            .then(() => {
                addSuccessNotification(isIncluded
                    ? {
                        msg: intl.formatMessage(messages.notificationDisableSuccess, { count, systemName })
                    }
                    : {
                        msg: intl.formatMessage(messages.notificationEnableSuccessTitle, { count, systemName }),
                        description: intl.formatMessage(messages.notificationEnableSuccessBody)
                    }
                );
            }).catch(error => {
                addFailureNotification(
                    error.status === '503' ? ReadOnlyNotification :
                        error.status === '403' ? NotAuthorizedNotification :
                            isIncluded
                                ? {
                                    msg: intl.formatMessage(messages.notificationDisableFailureTitle, { count, systemName }),
                                    description: intl.formatMessage(messages.notificationDisableFailureBody, { count })
                                }
                                : {
                                    msg: intl.formatMessage(messages.notificationEnableFailureTitle, { count, systemName }),
                                    description: intl.formatMessage(messages.notificationEnableFailureBody, { count })
                                }
                );
            }).finally(onRefreshInventory);
    };
};

// eslint-disable-next-line camelcase
const mapSelectedRows = ({ id, inventory_id: inventoryId, attributes, remediation, display_name, opt_out, ...rest }) =>
    ({
        ...rest,
        id: id ? id : inventoryId,
        selected: true,
        remediation: attributes ? attributes.remediation : remediation,
        // eslint-disable-next-line camelcase
        display_name: attributes ? attributes.display_name : display_name,
        // eslint-disable-next-line camelcase
        opt_out: attributes ? attributes.opt_out : opt_out
    });

export const useBulkSelect = ({ rawData, selectedRows, selectedRowsCount, handleSelect, fetchResource, multiRow = false }) => {
    const intl = useIntl();
    const { meta, data } = rawData;

    const selectPageNumber = data && (((Array.isArray(data) && data.length) && multiRow) ? data.length / 2 : data.length);

    const handleSelectPage = () => {
        const { data } = rawData ?? {};
        const mappedRows = data?.map(mapSelectedRows);
        // union with already selected rows (in case we are selecting another page)
        handleSelect(unionBy(mappedRows, selectedRows, 'id'), true);
    };

    const handleUnselect = () => {
        handleSelect(selectedRows.map(selectedRow => ({ ...selectedRow, selected: false })), false);
    };

    const handleSelectAll = async () => {
        let { payload } = await fetchResource({ page_size: meta.totalItems, page: 1 });

        payload.then(({ data }) => handleSelect(data.map(mapSelectedRows)), true);
    };

    return {
        count: selectedRowsCount,
        checked: !!selectedRowsCount,
        isDisabled: meta.totalItems === 0 && selectedRowsCount === 0,
        ouiaId: 'bulk-select',
        items: [
            {
                title: intl.formatMessage(messages.selectNone),
                onClick: handleUnselect
            },
            {
                title: `${intl.formatMessage(messages.selectPage, { count: selectPageNumber })}`,
                onClick: handleSelectPage
            },
            {
                title: `${intl.formatMessage(messages.selectAll, { count: meta.totalItems })}`,
                onClick: handleSelectAll
            }
        ],
        onSelect: () => !selectedRowsCount ? handleSelectAll() : handleUnselect()
    };

};

const matchPermissions = (permissionA, permissionB) => {
    const segmentsA = permissionA.split(':');
    const segmentsB = permissionB.split(':');

    if (segmentsA.length !== segmentsB.length) {
        return false;
    }

    return segmentsA.every((segmentA, index) => segmentA === segmentsB[index] || segmentA === '*' || segmentsB[index] === '*');
};

/**
 * Checks whether user has particular permissions
 * @param {array} requestedPermissions - array of strings each represening a permission (defined in constants.js > PERMISSIONS)
 * @param app - application to get permissions for
 * @returns {array} - array where first element is an array of bools, representing each permission from parameter array,
 * second element is bool whether permissions are loading
 */
export const useRbac = (requestedPermissions, app = 'vulnerability') => {
    const [allPermissions, setAllPermissions] = useState([]);
    const [loading, setLoading] = useState(true);
    const chrome = useChrome();

    useEffect(() => {
        chrome?.getUserPermissions?.(app, true).then(permissions => {
            setAllPermissions(permissions);
            setLoading(false);
        });
    }, []);

    if (loading) {
        return [requestedPermissions.map(() => []), true];
    }

    return [requestedPermissions.map(requestedPermission =>
        allPermissions?.some(item => matchPermissions(item.permission, requestedPermission))), false];
};

export const useColumnManagement = (columns, onApply) => {
    const [isModalOpen, setModalOpen] = useState(false);

    return [(
        <ColumnManagementModal
            appliedColumns={columns}
            applyColumns={newColumns => onApply(newColumns)}
            isModalOpen={isModalOpen}
            setModalOpen={setModalOpen}
            key="column-mgmt-modal"
        />), setModalOpen];
};
