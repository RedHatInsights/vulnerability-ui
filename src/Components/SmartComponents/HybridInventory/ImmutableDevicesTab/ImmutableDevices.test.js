import React from 'react';
import '@testing-library/jest-dom';
import { screen, waitFor } from '@testing-library/react';
import { ComponentWithContext } from '../../../../Utilities/TestingUtilities';
import ImmutableDevices from './ImmutableDevices';
import { render } from '@testing-library/react';
import AsynComponent from '@redhat-cloud-services/frontend-components/AsyncComponent';
import { useGetEntities } from './helpers';
import ReducerRegistry from '../../../../Utilities/ReducerRegistry';
import { useRbac } from '../../../../Helpers/Hooks';
import { useSelector } from 'react-redux';

jest.mock('@redhat-cloud-services/frontend-components/AsyncComponent', () => ({
  __esModule: true,
  default: jest.fn((props) => (
    <div {...props} aria-label="immutableDevices-module-mock">
      AsyncComponent
    </div>
  )),
}));

jest.mock('@unleash/proxy-client-react', () => ({
  ...jest.requireActual('@unleash/proxy-client-react'),
  useFlag: () => true,
  useFlagsStatus: () => ({ flagsReady: true }),
}));

jest.mock('./helpers', () => ({
  ...jest.requireActual('./helpers'),
  useGetEntities: jest.fn(() => {}),
}));

jest.mock('../../../../Helpers/Hooks', () => ({
    ...jest.requireActual('../../../../Helpers/Hooks'),
    useRbac: jest.fn(() => ([ [true], false ] )),
  }));

jest.mock('react-redux', () => ({
    ...jest.requireActual('react-redux'),
    useSelector: jest.fn((state) => state)
}));

const renderAndWait = async (componentProps = {}, renderOptions = { store: ReducerRegistry.getStore() }) => {
    const { container } = render(
        <ComponentWithContext
        Component={ImmutableDevices}
        componentProps={componentProps}
        renderOptions={renderOptions}
        />
    );

    await waitFor(() => {
        expect(
        screen.getByLabelText('immutableDevices-module-mock')
        ).toBeInTheDocument();
    });

    return container;
};

afterEach(() => {
    jest.clearAllMocks();
});

describe('ImmutableDevices', () => {
  test('renders without issues', async () => {
    await renderAndWait();
  });

  test('renders with correct custom filters', async () => {
    useSelector.mockReturnValue({                
        page: 1, 
        page_size: 20, 
        sort: "-updated" 
    });

    await renderAndWait();
    expect(AsynComponent).toHaveBeenCalledWith(
      expect.objectContaining({
        customFilters: { 
            edgeParams: { 
                host_type: "edge", 
                page: 1, 
                page_size: 20, 
                sort: "-updated" 
            }
        }
      }),
      {}
    );
  });

  test('renders load ImmutableDevices federated module', async () => {
    await renderAndWait();

    expect(AsynComponent).toHaveBeenCalledWith(
      expect.objectContaining({
        appName: 'inventory',
        module: './ImmutableDevices',
      }),
      {}
    );
  });


  test('should display hostGroupFilter and os filter from the ImmutableDevices federated module', async () => {
    await renderAndWait();

    expect(AsynComponent).toHaveBeenCalledWith(
      expect.objectContaining({
        hideFilters: {
          all: true,
          hostGroupFilter: false,
          operatingSystem: false,
        },
      }),
      {}
    );
  });

  test('should call getEntities with correct function arguments', async () => {
    await renderAndWait({ cveName: 'test-cve' });
    expect(useGetEntities).toHaveBeenCalledWith({
        createRows: expect.any(Function),
        id:'test-cve',
    });
  });

  test('should display error state when user is not permitted', async () => {
    useRbac.mockReturnValue([[false], false]);
    useSelector.mockReturnValue({ hasError: true, errorCode: 503 });

    render(<ComponentWithContext
        Component={ImmutableDevices}
        componentProps={{}}
        renderOptions={{ store: ReducerRegistry.getStore() }}
    />);
    expect(
        screen.getAllByText('This page is temporarily unavailable')
    ).toHaveLength(1);
  });
});