import * as reactCore from '@patternfly/react-core';
import { Page, ToolbarGroup, ToolbarItem } from '@patternfly/react-core';
import * as reactIcons from '@patternfly/react-icons';
import * as pfReactTable from '@patternfly/react-table';
import { Main, TableToolbar } from '@redhat-cloud-services/frontend-components';
import { addNotification } from '@redhat-cloud-services/frontend-components-notifications';
import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/files/helpers';
import debounce from 'lodash/debounce';
import propTypes from 'prop-types';
import qs from 'query-string';
import React from 'react';
import { connect } from 'react-redux';
import * as reactRouterDom from 'react-router-dom';
import { withRouter } from 'react-router-dom';
import { dataShape } from '../../../Helpers/MiscHelper';
import { fetchSystems, optOutSystemsAction, setHeader, selectEntities } from '../../../Store/Actions/Actions';
import { inventoryEntitiesReducer } from '../../../Store/Reducers/InventoryEntitiesReducer';
import { sAllSystems } from '../../../Store/Selectors/CVESelectors';
import ReducerRegistry, { middlewareListener } from '../../../Utilities/ReducerRegistry';
import VulnerabilityHeader from '../VulnerabilityHeader/VulnerabilityHeader';
import BaseKebab from '../../PresentationalComponents/DownloadReportKebab/BaseKebab';
import {
    kebabItemDownloadCSV,
    kebabItemDownloadJSON,
    kebabItemToggleExcludeSystemDisplay,
    kebabItemExcludeSystemAnalysis
} from '../../PresentationalComponents/DownloadReportKebab/KebabItems';
import './Systems.scss';
import SelectAllCheckbox from '../../PresentationalComponents/SelectAllCheckbox';
import { filterSystemName } from '../../../Helpers/constants';
import FilterChips  from '../../PresentationalComponents/Filters/FilterChips';
import SearchFilter  from '../../PresentationalComponents/Filters/SearchFilter';
import messages from '../../../Messages';
import { injectIntl } from 'react-intl';
/*eslint camelcase: 0*/

class Systems extends React.Component {
    static propTypes = {
        fetchData: propTypes.func,
        systems: dataShape,
        optOutSystems: propTypes.func,
        addNotification: propTypes.func,
        selectRows: propTypes.func,
        selectMultiple: propTypes.func,
        history: propTypes.object,
        location: propTypes.object,
        intl: propTypes.any
    };

    constructor(props) {
        super(props);
        this.state = {
            InventoryCmp: () => <div>Loading...</div>,
            filter: undefined,
            removeListener: () => { },
            columns: [
                {
                    key: 'display_name',
                    title: this.props.intl.formatMessage(messages.systemsColumnHeaderName),
                    composed: ['facts.os_release', 'display_name']
                },
                {
                    key: 'cve_count',
                    title: this.props.intl.formatMessage(messages.systemsColumnHeaderCveCount)
                }
            ],
            opt_out: false,
            isKebabOpen: false,
            selectListener: middlewareListener.addNew({
                on: 'SELECT_ENTITY',
                callback: payload => this.onSelect(payload)
            }),
            selectAllListener: middlewareListener.addNew({
                on: 'SELECT_ENTITIES',
                callback: payload => this.onSelect(payload)
            }),
            selected: new Set()
        };
    }

    componentDidMount() {

        const queryObject = qs.parse(this.props.location.search);
        queryObject.show_irrelevant = queryObject.show_irrelevant === 'true';
        if (queryObject.show_irrelevant) {
            queryObject.show_all = undefined;
        }

        this.fetchInventory();
        this.apply({ ...queryObject });
    }

    shouldComponentUpdate(nextProps) {
        return !nextProps.systems.isLoading;
    }

    downloadReport = format => {
        const { opt_out, filter } = this.state;
        const { payload } = fetchSystems({
            opt_out,
            filter,
            data_format: format,
            page: 1,
            page_size: Number.MAX_SAFE_INTEGER
        });
        payload &&
            payload.then(({ data: response }) => {
                const data = format === 'json' ? JSON.stringify(response) : response;
                return downloadFile(data, `systems-${new Date().toISOString()}`, format);
            });
    };

    async fetchInventory() {
        const { inventoryConnector, mergeWithEntities, mergeWithDetail } = await insights.loadInventory({
            react: React,
            reactRouterDom,
            reactCore,
            reactIcons,
            pfReactTable
        });
        ReducerRegistry.register({
            ...mergeWithEntities(inventoryEntitiesReducer(this.state.columns, this.getSelected)),
            ...mergeWithDetail()
        });

        this.setState({
            InventoryCmp: inventoryConnector(ReducerRegistry.getStore()).InventoryTable
        });
        this.state.removeListener();
    }

    apply = (config = {}) => {
        this.setState({ ...this.state, ...config }, this.sendRequest);
    };

    sendRequest = () => {
        const { fetchData } = this.props;
        fetchData({ ...this.state });
        this.createUrlParams(this.state);
    }

    createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = ['filter', 'page', 'page_size'];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        this.props.history.push('?' + queryString);
    };

    addFilter = (param, value, type) => {
        let newFilter;
        if (type === 'radio' || param === 'show_all') {
            newFilter = { [param]: value };
        } else {
            newFilter = this.state[param] ? { [param]: `${this.state[param]},${value}` } : { [param]: value };
        }

        this.apply({ ...newFilter, page: 1 });
    };

    doOptOut = () => {
        if (this.state.selected.size > 0) {
            this.props.optOutSystems(this.state.selected, !this.state.opt_out).then(() => {
                this.props.fetchData({ ...this.params(), page: 1 });
                this.state.opt_out === false
                    ? this.props.addNotification({
                        variant: 'success',
                        title: this.state.selected.size + this.props.intl.formatMessage(messages.systemsExcludedNotification)
                    })
                    : this.props.addNotification({
                        variant: 'success',
                        title: this.state.selected.size + this.props.intl.formatMessage(messages.systemsResumedNotificationTitle),
                        description: this.props.intl.formatMessage(messages.systemsResumedNotificationBody)
                    });
                this.setState({ selected: new Set() });
            });
        }
    };

    onSelect = (payload) => {
        let selected;
        if (!payload.data || Array.isArray(payload.data)) {
            selected = new Set(payload.data);
        } else {
            selected = this.state.selected;
            payload.data.selected ? selected.add(payload.data.id) : selected.delete(payload.data.id);
        }

        this.setState({ selected }, this.props.selectMultiple);
    };

    getSelected = () => {
        return this.state.selected;
    };

    params = () => {
        const { filter, opt_out, page, page_size } = this.state;
        return { filter, opt_out, page, page_size };
    };

    handleFilterChange = debounce(value => {
        const { meta } = this.props.systems;
        const { page_size } = meta;
        this.apply({ filter: value, page_size, page: 1 });
    }, 400);

    handleRefresh = ({ page, per_page: perPage }) => {
        const { meta } = this.props.systems;
        const { fetchData } = this.props;
        if (meta.page !== page || meta.page_size !== perPage) {
            const config = {
                page,
                page_size: perPage || meta.page_size,
                filter: this.state.filter,
                opt_out: this.state.opt_out
            };
            fetchData(config);
            this.createUrlParams(config);
        }
    };

    handleOptOut = () => {
        this.setState({
            opt_out: !this.state.opt_out,
            selected: new Set(),
            page: 1
        }, this.sendRequest);
    };

    handleKebabToggle = isKebabOpen => {
        this.setState({
            isKebabOpen
        });
    };

    handleKebabSelect = () => {
        this.setState({
            isKebabOpen: !this.state.isKebabOpen
        });
    };

    render() {
        const { InventoryCmp, filter } = this.state;
        const { data, meta } = this.props.systems;
        const items = data.map(item => {
            const { cve_count, ...rest } = item.attributes;
            return {
                cve_count: (meta.opt_out && 'Excluded') || cve_count,
                id: item.attributes.inventory_id,
                ...rest
            };
        });

        const kebabOptions = [
            kebabItemExcludeSystemAnalysis(this.doOptOut, this.state.opt_out, {
                isDisabled: !this.getSelected().size
            }),
            kebabItemToggleExcludeSystemDisplay(this.handleOptOut, this.state.opt_out),
            kebabItemDownloadJSON(this.downloadReport),
            kebabItemDownloadCSV(this.downloadReport)
        ];
        return (
            <Page>
                <VulnerabilityHeader showBreadcrumb={false} />
                <Main>
                    <InventoryCmp
                        hasCheckbox={data.length !== 0}
                        page={meta.page}
                        total={meta.total_items}
                        perPage={meta.page_size}
                        onRefresh={this.handleRefresh}
                        items={items}
                    >

                        <ToolbarGroup className="systems-toolbar">
                            <ToolbarItem>
                                <SelectAllCheckbox
                                    selectedItems={this.state.selected}
                                    selectorHandler={this.props.selectRows}
                                    items={this.props.systems}
                                    fetchResource={ops => fetchSystems({ ...this.params(), ...ops })}
                                />
                            </ToolbarItem>

                            <ToolbarItem>
                                <SearchFilter
                                    placeholder={this.props.intl.formatMessage(messages.searchFilterByName)}
                                    value={filter}
                                    apply={this.apply}
                                />
                            </ToolbarItem>

                            <ToolbarItem>
                                <BaseKebab dropdownItems={kebabOptions} disabled={data.length === 0} />
                            </ToolbarItem>
                        </ToolbarGroup>
                        <TableToolbar className="pf-u-pl-0 system-filter-chips">
                            <ToolbarGroup>
                                <ToolbarItem>
                                    <FilterChips
                                        filterValues={this.params()}
                                        filterCategories={[filterSystemName]}
                                        apply={this.apply}
                                    />
                                </ToolbarItem>
                            </ToolbarGroup>
                        </TableToolbar>
                    </InventoryCmp>
                </Main>
            </Page>
        );
    }
}

function mapStateToProps(state) {
    return {
        systems: sAllSystems(state)
    };
}

const mapDispatchToProps = dispatch => {
    return {
        setHeader: header => dispatch(setHeader(header)),
        fetchData: options => dispatch(fetchSystems(options)),
        optOutSystems: (systems, status) => dispatch(optOutSystemsAction(systems, status)),
        addNotification: notification => dispatch(addNotification(notification)),
        selectRows: (value, ids) => dispatch(selectEntities(value, ids)),
        selectMultiple: () => dispatch({ type: 'SELECT_MULTIPLE_ENTITIES' })
    };
};

export default injectIntl(
    withRouter(
        connect(
            mapStateToProps,
            mapDispatchToProps
        )(Systems)
    )
);

