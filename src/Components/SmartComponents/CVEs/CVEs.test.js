import CVEs from './CVEs';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import { BrowserRouter as Router } from 'react-router-dom';
import toJson from 'enzyme-to-json';
import { initialState } from '../../../Store/Reducers/CVEsStore'
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import { useSelector } from 'react-redux';
import DownloadReport from '../../../Helpers/DownloadReport';
import { act } from "react-dom/test-utils";

jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

const state = {
    ...initialState,
    parameters: { },
    cveList: {
        isLoading: false,
        payload: {
            meta: {
                test: 'test'
            },
            data: [
                {
                    type: 'cve',
                    id: 'CVE-2019-6454',
                    attributes: {
                        business_risk: "Not Defined",
                        business_risk_id: 0,
                        business_risk_text: null,
                        cve_status_id: 2,
                        cve_status_text: "testhello",
                        cvss2_score: null,
                        cvss3_score: "6.500",
                        description: "A new domain bypass",
                        impact: "Moderate",
                        public_date: "2020-06-09T17:00:00+00:00",
                        reporter: 1,
                        rule: null,
                        status: "On-Hold",
                        status_id: 2,
                        status_text: "testhello",
                        synopsis: "CVE-2020-0543",
                        systems_affected: 1,
                        rule: 'testRule'
                    }
                }
            ]
        }
    },
    upsupported: false

};

const customMiddleWare = store => next => action => {
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: state });
    });
    next(action);
  }
const mockStore = configureStore([customMiddleWare]);
const store = mockStore(initialState);

let wrapper;
beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: initialState });
    });
    wrapper = mountWithIntl(
        <Provider store={store}>
            <Router><CVEs/></Router>
        </Provider>
    ); 
});

afterEach(() => {
    useSelector.mockClear();
});

describe('CVEs', () => {
    it('Should render without props', () => {
        expect(toJson(wrapper)).toMatchSnapshot();
    });

    it('Should dispatch CHANGE_CVE_LIST_PARAMETERS and FETCH_CVE_LIST only once on load', () => {
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'FETCH_CVE_LIST')).toHaveLength(1);
    });

    it('Should clear store on unmount', () => {
        wrapper.unmount();
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'CLEAR_CVEs_STORE')).toHaveLength(1);
    });

    it('Should generate GenericError', () => {
        const customMiddleWareErrors = store => next => action => {
            useSelector.mockImplementation(callback => {
                return callback({ 
                    CVEsStore: {
                        ...initialState,
                        cveList: { isLoading:false, payload: { errors: true, meta: {}, data: [] } }
                    } 
                });
            });
            next(action);
          }
        const mockStoreErrors = configureStore([customMiddleWareErrors]);
        const storeForErrors = mockStoreErrors(initialState);
        const wrapperForErrors = mountWithIntl(
            <Provider store={storeForErrors}>
                <Router><CVEs/></Router>
            </Provider>
        );
        expect(wrapperForErrors.find('[id="error.reload"]')).toBeTruthy();
    });

    it('Should wrap with context provider of shape', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        expect(context).toEqual( 
                {
                    cves: {
                        data: expect.any(Array),
                        meta:  expect.any(Object),
                        isLoading: false,
                        errors: undefined
                    },
                    params: {},
                    selectedCves: [],
                    openedCves: [],
                    expandCveDescription: false,
                    methods: {
                        apply: expect.any(Function),
                        downloadReport: expect.any(Function),
                        selectCves: expect.any(Function),
                        showBusinessRiskModal: expect.any(Function),
                        showStatusModal: expect.any(Function),
                        openCves: expect.any(Function)
                    }
            }
        );
    });

    it('Should dispatch selectCve action on selecting (an) entitiy/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.selectCves(false, ['testId']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual(['testId']);
    });

    it('Should dispatch selectCve action with empty array if no cveNames supplied on selecting (an) entitiy/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.selectCves();
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual([]);
    });

    it('Should call Download exec with format and parameters', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.downloadReport('json');

        expect(DownloadReport.exec).toHaveBeenCalled();
    });

    it('Should display business risk modal', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        act(() => context.methods.showBusinessRiskModal([]));
        wrapper.update();
        expect(wrapper.find('BusinessRiskModal')).toBeTruthy();
    });

    it('Should display status modal modal', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        act(() => context.methods.showStatusModal([{ id: 'testId', status_id: 'testStatusId' }]));
        wrapper.update();
        const modal = wrapper.find('CveStatusModal');
        const { cves } = modal.props();
        expect(modal).toBeTruthy();
        expect(cves).toEqual([ { id: 'testId', status_id: 'testStatusId' } ]);
    });

    it('Should dispatch selectCve action on selecting (an) entitiy/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.openCves(['testID']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')[0].payload).toEqual(['testID']);
    }); 
    
    it('Should dispatch changeParameters action on apply method call with provided parameters', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply({ test: 'testString '});
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        await action[1].payload.then(result => { expect(result).toEqual({ test: 'testString '})});        
        expect(action).toHaveLength(2);
    });

    it('Should apply method set filterParams to default {} when no parameter supplied', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply();
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        await action[1].payload.then(result => { expect(result).toEqual({})});        
        expect(action).toHaveLength(2);
    });

})