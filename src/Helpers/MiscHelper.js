import { SecurityIcon, UnknownIcon } from '@patternfly/react-icons';
import { SortByDirection } from '@patternfly/react-table';
import findIndex from 'lodash/findIndex';
import propTypes from 'prop-types';
import React from 'react';
import { impactList, PUBLIC_DATE_OPTIONS } from './constants';
import qs from 'query-string';
import { IntlProvider } from '@redhat-cloud-services/frontend-components-translations';

export const dataShape = propTypes.shape({
    data: propTypes.oneOfType([propTypes.object, propTypes.array]),
    meta: propTypes.object,
    isLoading: propTypes.bool
});

/**
 * Based on the  allowedParams it will construct the arguments for the API call
 * which is defined in the vulnerabilities-client. vulnerabilities-client is written is typescript
 * so we need to define and pass every single parameter. Order in allowedParams is important
 *
 * @param {Object} apiProps
 * @param {Array} allowedParams - order should align with the params in the vulnerabilities-client
 */
export function constructParameters(apiProps, allowedParams) {
    if (apiProps) {
        Object.keys(apiProps).forEach(
            key => (
                apiProps[key] === undefined
                || apiProps[key] === ''
            )
            && delete apiProps[key]
        );

        const params = allowedParams.map(item => apiProps[item]);

        return params;
    }

    return [];
}

// TODO DRY:similar to constructParameters
export function constructURLParameters(urlParams, allowedParams) {
    if (urlParams) {
        const params = { ...urlParams };
        Object.keys(urlParams).forEach(
            key => (
                params[key] === undefined
                || params[key] === ''
                || !allowedParams.includes(key)
                || params[key] === false
            )
            && delete params[key]

        );
        return params;
    }
}

export function formatDate(date = new Date(), includeTime = false) {
    const prepend = (number) => `${`${number}`.length === 1 ? '0' : ''}${number}`;
    const toFormat = new Date(date);

    if (toFormat instanceof Date && !isNaN(toFormat)) {
        const year = toFormat.getFullYear();
        const month = toFormat.getMonth() + 1; // month is zero indexed
        const day = toFormat.getDate();
        const hour = toFormat.getUTCHours();
        const minute = toFormat.getUTCMinutes();

        return includeTime
            ? `${year}-${prepend(month)}-${prepend(day)} ${prepend(hour)}:${prepend(minute)} UTC`
            : `${year}-${prepend(month)}-${prepend(day)}`;
    }

    return toFormat;
}

/**
 * Contructs the filters which have more than one parameter that needs to be passed
 * and resets all the parameteres when it's needed
 *
 * @param {Object} filterParams
 * @return {Object}
 */
export function constructFilterParameters(filterParams) {
    if (Object.prototype.hasOwnProperty.call(filterParams, 'publish_date')) {
        let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);

        if (typeof publicEntry !== 'undefined') {
            filterParams.public_from = publicEntry.from && formatDate(publicEntry.from);
            filterParams.public_to = publicEntry.to && formatDate(publicEntry.to);
        } else {
            filterParams.public_from = undefined;
            filterParams.public_to = undefined;
            filterParams.publish_date = undefined;
        }
    }

    return filterParams;
}

export function getImpactDetails(impact) {
    if (Object.keys(impactList).includes(impact)) {
        return {
            title: impactList[impact].title,
            color: impactList[impact].color,
            text: impactList[impact].text,
            titleContent: (
                <SecurityIcon size="lg" />
            )
        };
    } else {
        return {
            title: 'Unknown',
            color: 'black',
            text: '',
            titleContent: (
                <UnknownIcon size="lg" />
            )
        };
    }
}

export const createSortBy = (header, value) => {
    if (value) {
        let direction = value.indexOf('-') === 0 ? SortByDirection.desc : SortByDirection.asc;
        value = value.replace(/^(-|\+)/, '');
        const index = findIndex(header, item => item.key === value);
        let sort = {
            index,
            direction
        };
        return sort;
    }

    return {};
};

export const handleSortColumn = (key, direction, header, currentSort, apply) => {
    let columnName = header[key].key;
    const useDefault = currentSort && currentSort.substr(1) !== columnName;
    if (direction === SortByDirection.desc || useDefault) {
        columnName = '-' + columnName;
    }

    apply({ sort: columnName });
};

export const updateStateSet = (stateSet, names, value) => {
    [].concat(names).forEach(name => {
        value ? stateSet.add(name) : stateSet.delete(name);
    });
    return stateSet;
};

export const useUrlParams = (allowedParams) => {
    const url = new URL(window.location);
    const urlParams = qs.parse(url.search);

    const setUrlParams = (parameters) => {
        const searchParams = qs.stringify(constructURLParameters(parameters, allowedParams));
        window.history.replaceState(null, null, `${url.origin}${url.pathname}?${searchParams}`);
    };

    return [urlParams, setUrlParams];
};

export const updateRef = (meta, apply) => {
    const pages = parseInt(meta.pages);
    const page = parseInt(meta.page);
    const cvesCount = parseInt(meta.cvesCount);
    const goTo = (pages === page && page > 1 && cvesCount === 1) ? (pages - 1) : page;

    apply({ page: goTo });
};

export const mountWithIntl = (Component) => {
    const wrapper = mount(Component, {
        wrappingComponent: IntlProvider
    });
    const provider = wrapper.getWrappingComponent();
    provider.setProps({ locale: 'en' });

    return wrapper;
};

export const shallowWithIntl = (Component) => {
    const wrapper = shallow(Component, {
        wrappingComponent: IntlProvider
    });
    const provider = wrapper.getWrappingComponent();
    provider.setProps({ locale: 'en' });

    return wrapper;
};

export const insertIf = (condition, ...elements) => {
    return condition ? elements : [];
};

export const chunkArray = (array, chunkSize, callback = null, initialValue = 0) => {
    const chunks = [];
    let labelsNumber = [];
    while (array.length > 0) {
        labelsNumber = callback && [...array].slice(0, chunkSize).reduce(callback, initialValue);
        const chunk = array.splice(0, chunkSize === labelsNumber ? chunkSize : chunkSize - labelsNumber);
        chunks.push(chunk);
    }

    return chunks;
};

export const mergeObjectPropertyBy = (obj, mergeProperty) => {
    const grouped = obj.reduce((prev, issue) => {
        let key = issue.id;
        if (prev[key]) {
            prev[key] = {
                ...issue,
                [mergeProperty]: [
                    ...prev[key][mergeProperty],
                    ...issue[mergeProperty]
                ]
            };
        } else {
            prev[key] = issue;
        }

        return prev;
    }, {});

    return Object.values(grouped);
};
