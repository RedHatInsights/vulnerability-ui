import CVEs from './CVEs';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import { BrowserRouter as Router } from 'react-router-dom';
import toJson from 'enzyme-to-json';
import { initialState } from '../../../Store/Reducers/CVEsStore'
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import { useSelector } from 'react-redux';
import DownloadReport from '../../../Helpers/DownloadReport';
import { act } from "react-dom/test-utils";
import { CVES_DEFAULT_FILTERS } from '../../../Helpers/constants';

jest.mock('../../../Helpers/Hooks', () => ({
    ...jest.requireActual('../../../Helpers/Hooks'),
    useRbac: () => [[true, true, true], false]
}));

jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

const state = {
    ...initialState,
    parameters: {
        sort: '-public_date',
        ...CVES_DEFAULT_FILTERS
    },
    cveList: {
        isLoading: false,
        payload: {
            meta: {
                test: 'test'
            },
            data: [
                {
                    type: 'cve',
                    id: 'CVE-2019-6454',
                    attributes: {
                        business_risk: "Not Defined",
                        business_risk_id: 0,
                        business_risk_text: null,
                        cve_status_id: 2,
                        cve_status_text: "testhello",
                        cvss2_score: null,
                        cvss3_score: "6.500",
                        description: "A new domain bypass",
                        impact: "Moderate",
                        public_date: "2020-06-09T17:00:00+00:00",
                        reporter: 1,
                        rule: null,
                        status: "On-Hold",
                        status_id: 2,
                        status_text: "testhello",
                        synopsis: "CVE-2020-0543",
                        systems_affected: 1,
                        rule: 'testRule',
                        known_exploit: false
                    }
                }
            ]
        }
    },
    upsupported: false
};

const customMiddleWare = store => next => action => {
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: state });
    });
    next(action);
}
const mockStore = configureStore([customMiddleWare]);
const store = mockStore(initialState);

let wrapper;
beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: initialState });
    });
    wrapper = mountWithIntl(
        <Provider store={store}>
            <Router><CVEs /></Router>
        </Provider>
    );
});

afterEach(() => {
    useSelector.mockClear();
});

describe('CVEs', () => {
    it('Should render without props', () => {
        expect(toJson(wrapper)).toMatchSnapshot();
    });

    it('Should clear store on unmount', () => {
        wrapper.unmount();
        const dispatchedActions = store.getActions();
        setTimeout(() => {
            expect(dispatchedActions.includes('CLEAR_CVES_STORE')).toBeTruthy();
        })
    });

    it('Should generate error', () => {
        const customMiddleWareErrors = store => next => action => {
            useSelector.mockImplementation(callback => {
                return callback({
                    CVEsStore: {
                        ...initialState,
                        cveList: { isLoading: false, payload: { errors: true, meta: {}, data: [] } }
                    }
                });
            });
            next(action);
        }
        const mockStoreErrors = configureStore([customMiddleWareErrors]);
        const storeForErrors = mockStoreErrors(initialState);
        const wrapperForErrors = mountWithIntl(
            <Provider store={storeForErrors}>
                <Router><CVEs /></Router>
            </Provider>
        );
        expect(wrapperForErrors.find('[id="error.reload"]')).toBeTruthy();
    });

    it('Should wrap with context provider of shape', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        expect(context).toEqual(
            {
                cves: {
                    data: expect.any(Array),
                    meta: expect.any(Object),
                    isLoading: false,
                    errors: undefined
                },
                params: {
                    sort: '-public_date',
                    ...CVES_DEFAULT_FILTERS
                },
                selectedCves: [],
                selectedRowsRawData: [],
                expandedRows: [],
                isAllExpanded: false,
                methods: {
                    apply: expect.any(Function),
                    downloadReport: expect.any(Function),
                    selectCves: expect.any(Function),
                    setColumnModalOpen: expect.any(Function),
                    showBusinessRiskModal: expect.any(Function),
                    showStatusModal: expect.any(Function),
                    openCves: expect.any(Function)
                }
            }
        );
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.selectCves(false, ['testId']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual(['testId']);
    });

    it('Should dispatch selectCve action with empty array if no cveNames supplied on selecting (an) entity/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.selectCves();
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual([]);
    });

    it('Should call Download exec with format and parameters', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.downloadReport('json');

        expect(DownloadReport.exec).toHaveBeenCalled();
    });

    it('Should display business risk modal', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        act(() => context.methods.showBusinessRiskModal([]));
        wrapper.update();
        expect(wrapper.find('BusinessRiskModal')).toBeTruthy();
    });

    it('Should display status modal modal', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        act(() => context.methods.showStatusModal([{ id: 'testId', status_id: 'testStatusId' }]));
        wrapper.update();
        const modal = wrapper.find('CveStatusModal');
        const { cves } = modal.props();
        expect(modal).toBeTruthy();
        expect(cves).toEqual([{ id: 'testId', status_id: 'testStatusId' }]);
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.openCves(['testID']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')[0].payload).toEqual(['testID']);
    });

    it('Should dispatch changeParameters action on apply method call with provided parameters', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply({ test: 'testString' });
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({ test: 'testString' });
        expect(action).toHaveLength(2);
    });

    it('Should apply method set filterParams to default {} when no parameter supplied', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply();
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({});
        expect(action).toHaveLength(2);
    });
})
