import SystemCveTableToolbar from './SystemCveTableToolbar';
import { CVETableContext } from './SystemCves';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import toJson from 'enzyme-to-json';
import { createCveListBySystem } from '../../../Helpers/VulnerabilityHelper';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import { initialState } from '../../../Store/Reducers/SystemCvesStore';
import { BrowserRouter as Router } from 'react-router-dom';
import {
    handleChangePage,
    handleSetPageSize, 
    removeFilters
} from '../../../Helpers/TableToolbarHelper';


jest.mock('../../../Helpers/TableToolbarHelper', () => (
    {
      ...(jest.requireActual('../../../Helpers/TableToolbarHelper')),
      handleChangePage: jest.fn(),
      handleSetPageSize: jest.fn(),
      removeFilters: jest.fn()
    }
));

const mockContext = {
    cves: createCveListBySystem('CVE-2019-6454', {
            payload: {
                isLoading: false,
                meta: {
                    test: 'test'
                },
                data: [
                    {
                        type: 'cve',
                        id: 'CVE-2019-6454',
                        attributes: {
                            business_risk: "Not Defined",
                            business_risk_id: 0,
                            business_risk_text: null,
                            cve_status_id: 2,
                            cve_status_text: "testhello",
                            cvss2_score: null,
                            cvss3_score: "6.500",
                            description: "A new domain bypass",
                            impact: "Moderate",
                            public_date: "2020-06-09T17:00:00+00:00",
                            reporter: 1,
                            rule: { id: 'testId', description: 'testDescription', summary: 'testSummary'},
                            status: "On-Hold",
                            status_id: 2,
                            status_text: "testhello",
                            synopsis: "CVE-2020-0543",
                            systems_affected: 1
                        }
                    }
                ]

            }
    }),
    parameters: { filter: 'testFilter'},
    selectedCves: ['CVE-2019-6454'],
    expandedRows: ['CVE-2019-6454'],
    isAllExpanded: false,
    methods: {
        apply: jest.fn(),
        downloadReport: jest.fn(),
        selectCves: jest.fn(),
        showStatusModal: jest.fn(),
        openCves: jest.fn(),
        fetchResource: jest.fn().mockReturnValue({ 
            payload: Promise.resolve({
                data: [{ id: 'testID' }]
            })
        })
    }
};

window.insights = { loadRemediations: jest.fn(), chrome: { getUserPermissions: jest.fn() } }
const customMiddleWare = store => next => action => {
    next(action);
  }
const mockStore = configureStore([customMiddleWare]);
const store = mockStore(initialState);

describe('SystemCvesTableToolbar', () => {

        
    const mountWithStore = (testContext = {}) => 
        mountWithIntl(
            <Provider store={store}>
                <Router>
                    <CVETableContext.Provider value={{ ...mockContext, ...testContext, canRemediate: true, canEditStatus: true }}>
                        <SystemCveTableToolbar entity={'CVE-2019-6454'} />
                    </CVETableContext.Provider>
                </Router>
            </Provider>
        );

    const mountWithoutStore = (testContext) => 
        mountWithIntl(
            <CVETableContext.Provider value={testContext}>
                <SystemCveTableToolbar entity={'CVE-2019-6454'} />
            </CVETableContext.Provider>
        );

    it('Should render without errors', () => {
        const wrapper = mountWithoutStore(mockContext);
        expect(toJson(wrapper)).toMatchSnapshot();
    });

    it('Should CVEsTableToolbarWithContext inherit default props', () => {
        let testcontext = { ...mockContext, methods: {} };
        const tempWrapper = mountWithoutStore(testcontext);
        const { totalNumber, apply, downloadReport } = tempWrapper.find('SystemCveToolbarWithContext').props();
        expect(totalNumber).toEqual(0);
        expect(apply()).toEqual(undefined);
        expect(downloadReport()).toEqual(undefined);
        tempWrapper.unmount();
        testcontext = {};
    });
    
    describe('actionsConfig:', () => {
        it('Should kebabToggleProps be disabled when no item is selected and there is not data', () => {
            const testcontext = { ...mockContext, cves: { isLoading: false, meta: { total_items: 0 }, data: [] }};
            const wrapper = mountWithoutStore(testcontext);
            const { actionsConfig: { kebabToggleProps } } = wrapper.find('PrimaryToolbar').props();
            expect(kebabToggleProps.isDisabled).toBeTruthy();
        })

        it('Should  openCves be called with testCve if isAllExpanded = false', () => {
            const wrapper = mountWithStore();
            const { actionsConfig: { actions } } = wrapper.find('PrimaryToolbar').props();
            actions[2].onClick();
            expect(mockContext.methods.openCves).toHaveBeenCalledWith(true, ["CVE-2019-6454"], true);
        });
    
        it('Should openCves be called with empty array if isAllExpanded = true', () => {
            let tempContext = {  ...mockContext, isAllExpanded: true };
            const tempWrapper = mountWithStore(tempContext);
            const { actionsConfig: { actions } } = tempWrapper.find('PrimaryToolbar').props();
            actions[2].onClick();
            expect(tempContext.methods.openCves).toHaveBeenCalledWith(false, [], false);
            tempWrapper.unmount();
            tempContext = {};
        });
        
        it('Should  showStatusModal be called with item ID and status_id = 0', () => {
            const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
            const  wrapper = mountWithStore(testContext); 
            const { actionsConfig: { actions } } = wrapper.find('PrimaryToolbar').props();
            actions[1].onClick();
            expect(mockContext.methods.showStatusModal).toHaveBeenCalledWith([{ id: 'testSelectedItem' }], []);
        });
    });
    
    describe('pagination:', () => {
        it('Should call handlePageChange on page change', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithStore(testContext); 
              const { pagination: { onSetPage } } = wrapper.find('PrimaryToolbar').props();
              onSetPage(null, 2);
              expect(handleChangePage).toHaveBeenCalledWith(null, 2, expect.any(Function));
        });

        it('Should call handleSetPageSize on page size change', () => {
            const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
            const wrapper = mountWithStore(testContext);
            const { pagination: { onPerPageSelect } } = wrapper.find('PrimaryToolbar').props();
            onPerPageSelect(null, 2);
            expect(handleSetPageSize).toHaveBeenCalledWith(null, 2, expect.any(Function));
      });
    });

    describe('bulkSelect:', () => {
        it('Should handleOnCheckboxChange unselect all selected items', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithStore(testContext);
              const { bulkSelect: { onSelect } } = wrapper.find('PrimaryToolbar').props();
              onSelect();
              expect(mockContext.methods.selectCves).toHaveBeenCalledWith(false, []);
        });
        it('Should handleOnCheckboxChange select all items', () => {
            const testContext = { ...mockContext, selectedCves: [] };
            const wrapper = mountWithStore(testContext);
            const { bulkSelect: { onSelect } } = wrapper.find('PrimaryToolbar').props();
            onSelect();
            expect(mockContext.methods.selectCves).toHaveBeenCalled();
      });
    });

    describe('activeFiltersConfig:', () => {
        it('Should call removeFilters with two parameters', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithStore(testContext);
              const { activeFiltersConfig: { onDelete } } = wrapper.find('PrimaryToolbar').props();
              onDelete(null, 'testitem');
              expect(removeFilters).toHaveBeenCalledWith('testitem', expect.any(Function));
        });
    });
});