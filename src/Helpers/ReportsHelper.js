import React from 'react';
import {
    CVE_REPORT_FILTERS,
    PUBLIC_DATE_OPTIONS,
    RULE_PRESENCE_OPTIONS,
    DEFAULT_FILTER_DATA,
    KNOWN_EXPLOIT_FILTER_OPTIONS
} from './constants';
import { formatDate } from './MiscHelper';
import { intl } from '../Utilities/IntlProvider';
import { Text } from '@react-pdf/renderer';
import styles from '../Components/SmartComponents/Reports/Common/styles';
import usePDFExport from '@redhat-cloud-services/frontend-components-utilities/useExportPDF';
import messages from '../Messages';

export const buildFilters = filterData => {
    let newValues = {};
    Object.entries(filterData).forEach(([key, value]) => {
        // if the filters value is default don't include it
        if (DEFAULT_FILTER_DATA[key] === value
            || value.length === 0
            || (Array.isArray(value) && value.length > 0 && value.length === CVE_REPORT_FILTERS[key]?.items?.length)
            || (key === 'cvss_filter' && value.from === 0 && value.to === 10)) {
            return;
        }

        newValues[key] = { filter: CVE_REPORT_FILTERS[key].title };

        switch (key) {
            case 'status_id':
            case 'business_risk_id':
            case 'impact': {
                const wordArray = value && Array.from(value).map(subvalue =>
                    CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue)
                        ? CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue).label
                        : '');
                newValues[key].values = wordArray.join(', ');
                break;
            }

            case 'publish_date':
                newValues[key].values = PUBLIC_DATE_OPTIONS.find(val => val.value === value).label;
                break;

            case 'rule_presence':
                newValues[key].values = value.map(
                    checkedValue => RULE_PRESENCE_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'known_exploit':
                newValues[key].values = value.map(
                    checkedValue => KNOWN_EXPLOIT_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'cvss_filter':
                newValues[key].values = value.from.toFixed(1) + ' - ' + value.to.toFixed(1);
                break;

            case 'rhel_version':
                newValues[key].values = value.map(version => `RHEL ${version}`).join(', ');
                break;

            case 'tags':
                newValues[key].values = value;
                break;

            default:
                newValues[key].values = value;
        }
    });

    return newValues;
};

export function constructReportParameters(filterParams, sorterParams) {
    let reportParams = constructFilterParameters(filterParams);
    reportParams.sort = sorterParams;
    return reportParams;
}

export function constructFilterParameters(filterParams) {
    // construct publish date
    let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);
    let from = undefined;
    let to = undefined;

    if (typeof publicEntry !== 'undefined') {
        from = publicEntry.from && formatDate(publicEntry.from);
        to = publicEntry.to && formatDate(publicEntry.to);
    }

    // FIXME contruct should be dynamic
    // construct rest of params
    let newParams = {
        status_id: filterParams.status_id.toString(),
        business_risk_id: filterParams.business_risk_id.toString(),
        impact: filterParams.impact.toString(),
        cvss_from: filterParams.cvss_filter.from,
        cvss_to: filterParams.cvss_filter.to,
        publish_date: filterParams.publish_date,
        public_from: from,
        public_to: to,
        rule_presence: filterParams.rule_presence.toString(),
        known_exploit: filterParams.known_exploit.toString(),
        rhel_version: filterParams.rhel_version.toString(),
        tags: filterParams.tags?.map(tag => tag.string).join(',')
    };

    return newParams;
}

export const intlFormatWithBold = (msg, params) => {
    return intl.formatMessage(msg, { ...params, b: (...chunks) => <Text style={styles.bold}>{chunks}</Text> });
};

export const buildCveReportConfig = ({ filters = {}, intl, reportData, user }) => {

    let filterStringSegments = [
        { name: 'impact', msg: messages.CVEsPDFreportFiltersSeverity, lowercase: true },
        { name: 'business_risk_id', msg: messages.CVEsPDFreportFiltersBusinessRisk, lowercase: true },
        { name: 'status_id', msg: messages.CVEsPDFreportFiltersStatus, lowercase: true },
        { name: 'rule_presence', msg: messages.CVEsPDFreportFiltersDefinedValue, lowercase: true },
        { name: 'known_exploit', msg: messages.CVEsPDFreportFiltersDefinedValue, lowercase: true },
        { name: 'rhel_version', msg: messages.CVEsPDFreportFiltersOsVersion }
    ];

    let filtersUsedMessage = intl.formatMessage(
        messages.customReportSearchTermCvssAndPublishDate,
        {
            hasSearchTerm: filters?.hasOwnProperty('filter') ? 'yes' : 'no',
            searchTerm: filters.filter?.values && filters.filter?.values,
            score: (
                filters.cvss_filter?.values && filters.cvss_filter.values
            ) || DEFAULT_FILTER_DATA.cvss_filter.from.toFixed(1) + ' - ' +
                    DEFAULT_FILTER_DATA.cvss_filter.to.toFixed(1),
            published: (
                filters.publish_date?.values && `withing ${filters.publish_date.values.toLowerCase()}`
            ) || intl.formatMessage(messages.customReportTimespanAnytime),
            b: (...chunks) =>`<strong> ${chunks} </strong>`
        }
    ).concat('/n');

    filterStringSegments.filter(filter => {
        return filters.hasOwnProperty(filter.name);
    }).forEach(filter => {
        filtersUsedMessage = filtersUsedMessage + intl.formatMessage(
            filter.msg,
            {
                values: filter.lowercase ?
                    filters[filter.name]?.values.toLowerCase() :
                    filters[filter.name].values,
                prefix: filters.isLast ? intl.formatMessage(messages.customReportAnd) : ';',
                b: (...chunks) => `<strong> ${chunks} </strong>`
            }
        );;
    });

    let activeTags;
    if (filters.tags && filters.tags.values) {
        activeTags = intl.formatMessage(messages.tagFilterParagraph) + ' ' +
        filters.tags.values.map(tag => `${tag.namespace}:${tag.key}=${tag.value}`).slice(0, 10).join(', ');

        if (filters.tags.values.length > 10) {
            activeTags = activeTags + ' ' +
                    intl.formatMessage(messages.tagFilterParagraphAndMore, { count: filters.tags.values.length - 10 });
        }
    }

    return {
        ...reportData,
        creator: `${user.identity.user.first_name} ${user.identity.user.last_name}`,
        filtersUsedMessage,
        activeTags
    };
};

export const useDownloadPDF = (dispatch) => {
    return usePDFExport('vulnerability', dispatch);
};
