import * as reactCore from '@patternfly/react-core';
import {
    Dropdown,
    DropdownItem,
    KebabToggle,
    Text,
    TextContent,
    TextVariants,
    ToolbarGroup,
    ToolbarItem
} from '@patternfly/react-core';
import * as reactIcons from '@patternfly/react-icons';
import * as pfReactTable from '@patternfly/react-table';
import { TableToolbar } from '@redhat-cloud-services/frontend-components';
import { addNotification } from '@redhat-cloud-services/frontend-components-notifications';
import RemediationButton from '@redhat-cloud-services/frontend-components-remediations/RemediationButton';
import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/files/helpers';
import debounce from 'lodash/debounce';
import propTypes from 'prop-types';
import qs from 'query-string';
import React from 'react';
import { connect } from 'react-redux';
import * as reactRouterDom from 'react-router-dom';
import { withRouter } from 'react-router-dom';
import { filtersStatus } from '../../../Helpers/constants';
import { dataShape } from '../../../Helpers/MiscHelper';
import { systemExposedTableRowActions } from '../../../Helpers/CVEHelper';
import { fetchAffectedSystemsByCVE, handleCveDetailsError } from '../../../Store/Actions/Actions';
import { inventoryEntitiesReducer } from '../../../Store/Reducers/InventoryEntitiesReducer';
import { sExposedSystemsTable } from '../../../Store/Selectors/CVESelectors';
import ReducerRegistry, { middlewareListener } from '../../../Utilities/ReducerRegistry';
import FilterChips from '../../PresentationalComponents/Filters/FilterChips';
import Filters from '../../PresentationalComponents/Filters/Filters';
import './SystemsExposedTable.scss';
import CvePairStatusModal from '../Modals/CvePairStatusModal';

/*eslint camelcase: 0*/

class SystemsExposedTable extends React.Component {
    static propTypes = {
        cve: propTypes.string,
        fetchData: propTypes.func,
        affectedSystems: dataShape,
        history: propTypes.object,
        handleCveDetailsError: propTypes.func,
        createNotification: propTypes.func
    };

    constructor(props) {
        super(props);

        this.state = {
            InventoryCmp: () => <div>Loading...</div>,
            removeListener: () => {},
            StatusModal: () => null,
            filter: '',
            columns: [
                {
                    key: 'display_name',
                    title: 'Name',
                    composed: ['facts.os_release', 'display_name'],
                    props: {
                        width: 40
                    }
                },
                {
                    key: 'status',
                    title: 'Status',
                    props: {
                        width: 30
                    }
                },
                {
                    key: 'updated',
                    title: 'Last seen',
                    isTime: true,
                    props: {
                        width: 30
                    }
                }
            ],
            isKebabOpen: false,
            selected: new Set(),
            selectListener: middlewareListener.addNew({
                on: 'SELECT_ENTITY',
                callback: payload => this.onSelect(payload)
            })
        };
    }

    componentDidMount() {
        this.fetchInventory();
    }

    onSelect = payload => {
        const { selected } = this.state;
        payload.data.selected ? selected.add(payload.data.id) : selected.delete(payload.data.id);
        this.setState({ selected });
    };

    getSelected = () => {
        return this.state.selected;
    };

    dataProvider = () => {
        return {
            issues: [
                {
                    id: `vulnerabilities:${this.props.cve}`,
                    description: this.props.cve
                }
            ],
            systems: Array.from(this.getSelected())
        };
    };

    // #TODO: can be better. Similar function exists in 2 other places.
    createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = ['filter', 'page', 'page_size', 'status_id'];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        this.props.history.push('?' + queryString);
    };

    dataReload = () => {
        const { meta, data } = this.props.affectedSystems;
        const lastPage = meta.page;
        const { page } = this.state;
        const reloadPage = page === lastPage && data.length === 1 ? 1 : meta.page;

        this.setState(
            {
                ...this.state,
                page: reloadPage,
                page_size: meta.page_size,
                filter: this.state.filter,
                system_id: this.state.system_id
            },
            this.apply
        );
    };

    apply = newFilter => {
        this.setState({ ...this.state, ...newFilter }, () => {
            this.sendRequest();
        });
    };

    sendRequest = () => {
        const { fetchData, cve, handleCveDetailsError } = this.props;

        fetchData &&
            fetchData(cve, this.params()).catch(() => {
                handleCveDetailsError();
            });

        this.createUrlParams(this.state);
    };

    downloadReport = format => {
        const { payload } =
            // eslint-disable-next-line camelcase
            fetchAffectedSystemsByCVE(this.props.cve, {
                ...this.state,
                data_format: format,
                page: 1,
                page_size: Number.MAX_SAFE_INTEGER
            });
        payload &&
            payload.then(({ data: response }) => {
                const data = format === 'json' ? JSON.stringify(response) : response;
                return downloadFile(data, `systems_affected-${this.props.cve}-${new Date().toISOString()}`, format);
            });
    };

    showStatusModal = (cves, inventoryIds) => {
        this.setState({
            StatusModal: () => (
                <CvePairStatusModal cves={cves} updateRef={this.apply} inventoryIds={inventoryIds} />
            )
        });
    };

    async fetchInventory() {
        const { inventoryConnector, mergeWithEntities, mergeWithDetail } = await insights.loadInventory({
            react: React,
            reactRouterDom,
            reactCore,
            reactIcons,
            pfReactTable
        });
        ReducerRegistry.register({
            ...mergeWithEntities(inventoryEntitiesReducer(this.state.columns, this.getSelected)),
            ...mergeWithDetail()
        });

        this.setState({
            InventoryCmp: inventoryConnector().InventoryTable
        });
    }

    params = () => {
        const { filter, page, page_size, status_id } = this.state;
        return { filter, page, page_size, status_id };
    };

    handleFilterChange = debounce(value => {
        this.setState({ ...this.state, filter: value }, this.apply);
    }, 400);

    handleRemediationCreated = result => {
        this.props.createNotification(result.getNotification());
        this.setState({ selected: new Set() });
        this.props.fetchData(this.props.cve, this.params());
    };

    handleKebabToggle = isKebabOpen => {
        this.setState({
            isKebabOpen
        });
    };

    handleKebabSelect = () => {
        this.setState({
            isKebabOpen: !this.state.isKebabOpen
        });
    };

    handleRefresh = ({ page, per_page: perPage }) => {
        const { meta } = this.props.affectedSystems;
        if (meta.page !== page || meta.page_size !== perPage) {
            this.setState(
                {
                    ...this.state,
                    page: meta.page_size !== perPage ? 1 : page,
                    page_size: perPage,
                    filter: this.state.filter
                },
                this.apply
            );
        }
    };

    render() {
        const { StatusModal } = this.state;
        const { InventoryCmp } = this.state;
        const { affectedSystems, cve } = this.props;
        const { data, meta } = affectedSystems;
        const { showStatusModal } = this;
        const methods = { showStatusModal };

        return (
            <React.Fragment>
                <TextContent>
                    <Text component={TextVariants.h2}>Affected systems</Text>
                </TextContent>
                <InventoryCmp
                    hasCheckbox={data.length !== 0}
                    showActions={data.length !== 0}
                    actions={systemExposedTableRowActions(methods, cve)}
                    page={meta.page}
                    total={meta.total_items}
                    perPage={meta.page_size}
                    onRefresh={this.handleRefresh}
                    items={data.map(item => ({
                        id: item.attributes.inventory_id,
                        ...item.attributes
                    }))}
                >
                    <ToolbarGroup className={'affected-systems-toolbar'}>
                        <Filters
                            searchPlaceholder="Find a system by UUID"
                            filterCategories={[filtersStatus]}
                            filterValues={this.params()}
                            apply={this.apply}
                        />
                        <ToolbarItem>
                            <RemediationButton
                                dataProvider={this.dataProvider}
                                isDisabled={this.state.selected.size === 0}
                                onRemediationCreated={this.handleRemediationCreated}
                            />
                        </ToolbarItem>
                        <ToolbarItem>
                            <Dropdown
                                onSelect={this.handleKebabSelect}
                                toggle={<KebabToggle onToggle={this.handleKebabToggle} />}
                                isOpen={this.state.isKebabOpen}
                                isPlain
                                dropdownItems={[
                                    <DropdownItem key="json" component="button" onClick={() => this.downloadReport('json')}>
                                        Export as JSON
                                    </DropdownItem>,
                                    <DropdownItem key="csv" component="button" onClick={() => this.downloadReport('csv')}>
                                        Export as CSV
                                    </DropdownItem>
                                ]}
                            />
                        </ToolbarItem>
                    </ToolbarGroup>
                    <TableToolbar className="pf-u-pl-0">
                        <ToolbarGroup>
                            <ToolbarItem>
                                <FilterChips filterValues={this.params()} filterCategories={[filtersStatus]} apply={this.apply} />
                            </ToolbarItem>
                        </ToolbarGroup>
                    </TableToolbar>
                    <StatusModal />
                </InventoryCmp>
            </React.Fragment>
        );
    }
}

function mapStateToProps(state, ownProps) {
    return {
        affectedSystems: sExposedSystemsTable(state, ownProps.cve)
    };
}

const mapDispatchToProps = dispatch => {
    return {
        fetchData: (cve, options) => dispatch(fetchAffectedSystemsByCVE(cve, options)),
        handleCveDetailsError: () => dispatch(handleCveDetailsError()),
        createNotification: content => dispatch(addNotification(content))
    };
};

export default withRouter(
    connect(
        mapStateToProps,
        mapDispatchToProps
    )(SystemsExposedTable)
);
