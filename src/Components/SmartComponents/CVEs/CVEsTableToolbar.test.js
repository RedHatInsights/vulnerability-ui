import CVEsTableToolbar from './CVEsTableToolbar';
import { CVETableContext } from './CVEs';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import toJson from 'enzyme-to-json';
import {
    handleChangePage,
    handleSetPageSize, 
    removeFilters
} from '../../../Helpers/TableToolbarHelper';


jest.mock('../../../Helpers/TableToolbarHelper', () => (
    {
      ...(jest.requireActual('../../../Helpers/TableToolbarHelper')),
      handleChangePage: jest.fn(),
      handleSetPageSize: jest.fn(),
      removeFilters: jest.fn()
    }
));

const mockContext = {
    cves: {
        isLoading: false,
        meta: {
            test: 'test'
        },
        data: [
            {
                type: 'cve',
                id: 'CVE-2019-6454',
                attributes: {
                    business_risk: "Not Defined",
                    business_risk_id: 0,
                    business_risk_text: null,
                    cve_status_id: 2,
                    cve_status_text: "testhello",
                    cvss2_score: null,
                    cvss3_score: "6.500",
                    description: "A new domain bypass",
                    impact: "Moderate",
                    public_date: "2020-06-09T17:00:00+00:00",
                    reporter: 1,
                    rule: null,
                    status: "On-Hold",
                    status_id: 2,
                    status_text: "testhello",
                    synopsis: "CVE-2020-0543",
                    systems_affected: 1,
                    rule: 'testRule'
                }
            }
        ]

    },
    params: {},
    selectedCves: [],
    openedCves: [],
    expandCveDescription: false,
    methods: {
        apply: jest.fn(),
        downloadReport: jest.fn(),
        selectCves: jest.fn(),
        showBusinessRiskModal: jest.fn(),
        showStatusModal: jest.fn(),
        openCves: jest.fn()
    }
};

describe('CVEsTableToolbar', () => {
    it('Should render without errors', () => {
        const wrapper = mountWithIntl(
            <CVETableContext.Provider value={mockContext}>
                <CVEsTableToolbar/>
            </CVETableContext.Provider>
        ); 
        expect(toJson(wrapper)).toMatchSnapshot();
    });

    it('Should CVEsTableToolbarWithContext inherit default props', () => {
        let tempContext = { ...mockContext, methods: {} };
        const tempWrapper = mountWithIntl(
            <CVETableContext.Provider value={tempContext}>
                <CVEsTableToolbar/>
            </CVETableContext.Provider>
        );
        const { totalNumber, apply, downloadReport } = tempWrapper.find('CVEsTableToolbarWithContext').props();
        expect(totalNumber).toEqual(0);
        expect(apply()).toEqual(undefined);
        expect(downloadReport()).toEqual(undefined);
        tempWrapper.unmount();
        tempContext = {};
    });

    describe('actionsConfig:', () => {
        it('Should kebabToggleProps be disabled when no item is selected and there is not data', () => {
            const testcontext = { ...mockContext, cves: { isLoading: false, meta: { total_items: 0 }, data: [] }};
            const wrapper = mountWithIntl(
                <CVETableContext.Provider value={testcontext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { actionsConfig: { kebabToggleProps } } = wrapper.find('PrimaryToolbar').props();
            expect(kebabToggleProps.isDisabled).toBeTruthy();
        })
        it('Should  openCves be called with testCve if expandCveDescription = false', () => {
            const wrapper = mountWithIntl(
                <CVETableContext.Provider value={mockContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { actionsConfig: { actions } } = wrapper.find('PrimaryToolbar').props();
            actions[4].onClick();
            expect(mockContext.methods.openCves).toHaveBeenCalledWith(['CVE-2019-6454']);
        });
    
        it('Should openCves be called with empty array if expandCveDescription = true', () => {
            let tempContext = { ...mockContext, expandCveDescription: true };
            const tempWrapper = mountWithIntl(
                <CVETableContext.Provider value={tempContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            );
            const { actionsConfig: { actions } } = tempWrapper.find('PrimaryToolbar').props();
            actions[4].onClick();
            expect(tempContext.methods.openCves).toHaveBeenCalledWith([]);
            tempWrapper.unmount();
            tempContext = {};
        });
        
        it('Should  showStatusModal be called with item ID and status_id = 0', () => {
            const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
            const  wrapper = mountWithIntl(
                <CVETableContext.Provider value={testContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { actionsConfig: { actions } } = wrapper.find('PrimaryToolbar').props();
            actions[2].onClick();
            expect(mockContext.methods.showStatusModal).toHaveBeenCalledWith([{ id: 'testSelectedItem', "status_id": "0" }]);
        });

        it('Should  showBusinessRiskModal be called with item ID and business_risk_id = 0', () => {
            const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
            const wrapper = mountWithIntl(
                <CVETableContext.Provider value={testContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { actionsConfig: { actions } } = wrapper.find('PrimaryToolbar').props();
            actions[1].onClick();
            expect(mockContext.methods.showBusinessRiskModal).toHaveBeenCalledWith([{ id: 'testSelectedItem', "business_risk_id": "0" }]);
        });
    });
    
    describe('pagination:', () => {
        it('Should call handlePageChange on page change', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithIntl(
                  <CVETableContext.Provider value={testContext}>
                      <CVEsTableToolbar/>
                  </CVETableContext.Provider>
              ); 
              const { pagination: { onSetPage } } = wrapper.find('PrimaryToolbar').props();
              onSetPage(null, 2);
              expect(handleChangePage).toHaveBeenCalledWith(null, 2, expect.any(Function));
        });

        it('Should call handleSetPageSize on page size change', () => {
            const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
            const wrapper = mountWithIntl(
                <CVETableContext.Provider value={testContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { pagination: { onPerPageSelect } } = wrapper.find('PrimaryToolbar').props();
            onPerPageSelect(null, 2);
            expect(handleSetPageSize).toHaveBeenCalledWith(null, 2, expect.any(Function));
      });
    });

    describe('bulkSelect:', () => {
        it('Should handleOnCheckboxChange unselect all selected items', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithIntl(
                  <CVETableContext.Provider value={testContext}>
                      <CVEsTableToolbar/>
                  </CVETableContext.Provider>
              ); 
              const { bulkSelect: { onSelect } } = wrapper.find('PrimaryToolbar').props();
              onSelect();
              expect(mockContext.methods.selectCves).toHaveBeenCalledWith(false, []);
        });
        it('Should handleOnCheckboxChange select all items', () => {
            const testContext = { ...mockContext, selectedCves: [] };
            const wrapper = mountWithIntl(
                <CVETableContext.Provider value={testContext}>
                    <CVEsTableToolbar/>
                </CVETableContext.Provider>
            ); 
            const { bulkSelect: { onSelect } } = wrapper.find('PrimaryToolbar').props();
            onSelect();
            expect(mockContext.methods.selectCves).toHaveBeenCalled();
      });
    });

    describe('activeFiltersConfig:', () => {
        it('Should call removeFilters with two parameters', () => {
              const testContext = { ...mockContext, selectedCves: ['testSelectedItem'] };
              const wrapper = mountWithIntl(
                  <CVETableContext.Provider value={testContext}>
                      <CVEsTableToolbar/>
                  </CVETableContext.Provider>
              ); 
              const { activeFiltersConfig: { onDelete } } = wrapper.find('PrimaryToolbar').props();
              onDelete(null, 'testitem');
              expect(removeFilters).toHaveBeenCalledWith('testitem', expect.any(Function));
        });
    });
});