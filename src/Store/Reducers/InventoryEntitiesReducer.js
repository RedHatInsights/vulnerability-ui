import { selectRows } from './reducersHelper';
import * as ActionTypes from '../ActionTypes';
import unionBy from 'lodash/unionBy';

export const initialState = {
    loaded: false,
    tagsLoaded: false,
    allTagsLoaded: false,
    invConfig: {},
    sortBy: {
        key: 'updated',
        direction: 'desc'
    },
    page: 1,
    perPage: 20
};

function modifyInventory(columns, state, action) {
    let advisory = columns.find(({ key }) => key === 'advisory');

    if (!state.selectedRows) {
        state.selectedRows = {};
    }

    if (!state.sortBy) {
        state.sortBy = {
            key: 'updated',
            direction: 'desc'
        };
    }

    if (state.loaded) {
        let hasPatchAccess = state.rows.some(({ patchAccess }) => patchAccess);

        if (!hasPatchAccess && advisory) {
            advisory.isShown = false;
        }

        return {
            ...state,
            columns,
            rows: state.rows.map(row => ({
                ...row,
                selected: state.selectedRows[row.id] || false
            })),
            prevLoadedRows: unionBy(action.payload.results, state.prevLoadedRows, 'id'),
            meta: action.payload.meta
        };
    }

    return state;
}

export const inventoryEntitiesReducer = (columns) => (state = initialState, action) => {
    let newState = { ...state };

    switch (action.type) {
        case ActionTypes.LOAD_ENTITIES + '_FULFILLED':
            return modifyInventory(columns, newState, action);
        case ActionTypes.SELECT_ENTITY:
            return selectRows(newState, action);
        case ActionTypes.EXPAND_ROW:
            return {
                ...newState,
                rows: newState.rows.map(row => ({
                    ...row,
                    isOpen: row.id === action.payload.id ? action.payload.isOpen : row.isOpen
                }))
            };
        case ActionTypes.CLEAR_INVENTORY_STORE:
            return initialState;
        default:
            return newState;
    }
};
