import React, { useEffect, useState, lazy, Suspense, createContext } from 'react';
import PropTypes from 'prop-types';
import { Navigate, Route, Routes, useLocation } from 'react-router-dom';
import { checkEdgePresence, getRhelSystems, getCveListByAccount } from '../Helpers/APIHelper';
import { PATHS } from '../Helpers/constants';
import { intl } from './IntlProvider';
import messages from '../Messages';
import AsyncComponent from '@redhat-cloud-services/frontend-components/AsyncComponent';
import ErrorState from '@redhat-cloud-services/frontend-components/ErrorState';
import { useChrome } from '@redhat-cloud-services/frontend-components/useChrome';
import useFeatureFlag from './useFeatureFlag';
import { NotAuthorized } from '@redhat-cloud-services/frontend-components/NotAuthorized';
import { useNotification } from '../Helpers/Hooks';
import PageLoading from '../Components/PresentationalComponents/Snippets/PageLoading';

const SystemsPage = lazy(() =>
    import(
        /* webpackChunkName: "Systems" */ '../Components/SmartComponents/SystemsPage/SystemsPage'
    )
);

const LandingPage = lazy(() =>
    import(
        /* webpackChunkName: "LandingPage" */ '../Components/SmartComponents/LandingPage/LandingPage'
    )
);

const Upgrade = lazy(() =>
    import(
        /* webpackChunkName: "Upgrade" */ '../Components/PresentationalComponents/StaticPages/UpgradePage'
    )
);

const CVEDetailsPage = lazy(() =>
    import(
        /* webpackChunkName: "CVEDetailsPage" */ '../Components/SmartComponents/CVEDetailsPage/CVEDetailsPage'
    )
);

const SystemDetailsPage = lazy(() =>
    import(
        /* webpackChunkName: "SystemDetailsPage" */ '../Components/SmartComponents/SystemDetailsPage/SystemDetailsPage'
    )
);
const Reports = lazy(() =>
    import(/* webpackChunkName: "Reports" */ '../Components/SmartComponents/Reports/ReportsPage')
);

export const AccountStatContext = createContext({
    hasConventionalSystems: true,
    hasEdgeDevices: false
});
export const checkForAccountSystems = (isEdgeParityEnabled, hasEdgeDevices, hasConventionalSystems) => {
    return isEdgeParityEnabled && (hasEdgeDevices || hasConventionalSystems) || hasConventionalSystems;
};

export const useAccountStats = (isEdgeParityEnabled, setLoading, addNotification) => {
    const [hasEdgeDevices, setHasEdgeDevices] = useState(true);
    const [hasConventionalSystems, setHasConventionalSystems] = useState(true);
    const [includesCvesWithoutErrata, setIncludesCvesWithoutErrata] = useState();
    const [isAdvisoryAvailable, setAdvisoryAvailable] = useState();
    const [hasAccess, setHasAccess] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            try {
                const rhelSystems = await getRhelSystems();
                if (isEdgeParityEnabled) {
                    //if there is at least 1 edge device in the account level, not only in vulnerability
                    const edgeDevicePresent = await checkEdgePresence();
                    setHasEdgeDevices(edgeDevicePresent);
                }

                const { meta:
                    {
                        cves_without_errata: cvesWithoutErrata, advisory_available: advisoryAvailable
                    } = {}
                } =  await getCveListByAccount({ limit: 1 });

                setHasConventionalSystems(rhelSystems);
                setIncludesCvesWithoutErrata(cvesWithoutErrata);
                setAdvisoryAvailable(advisoryAvailable);
                setLoading(false);
            } catch (error) {
                if (error.status === '403') {
                    setHasAccess(false);
                }
                else {
                    addNotification({
                        variant: 'danger',
                        autoDismiss: false,
                        msg: 'Failed to fetch systems',
                        description: error.detail
                    });
                }

                setLoading(false);
            }
        };

        fetchData();
    }, []);

    return { hasEdgeDevices, hasConventionalSystems, includesCvesWithoutErrata, isAdvisoryAvailable, hasAccess };
};

export const AccountStatContextWrapper = ({ children, setLoading }) => {
    const isEdgeParityEnabled = useFeatureFlag('vulnerability.edge_parity');
    const [addNotification] = useNotification();

    const {
        hasConventionalSystems,
        hasEdgeDevices,
        includesCvesWithoutErrata,
        isAdvisoryAvailable
    } = useAccountStats(isEdgeParityEnabled, setLoading, addNotification);

    return (
        <AccountStatContext.Provider value={{
            hasConventionalSystems,
            hasEdgeDevices,
            includesCvesWithoutErrata,
            isAdvisoryAvailable
        }}>
            { children }
        </AccountStatContext.Provider>
    );
};

AccountStatContextWrapper.propTypes = {
    children: PropTypes.func,
    setLoading: PropTypes.func
};

export const InsightsElement = ({ element: Element, title, globalFilterEnabled,  ...elementProps }) => {
    let location = useLocation();
    const [isLoading, setLoading] = useState(true);
    const isEdgeParityEnabled = useFeatureFlag('vulnerability.edge_parity');
    const [addNotification] = useNotification();
    const chrome = useChrome();

    const {
        hasEdgeDevices,
        hasConventionalSystems,
        includesCvesWithoutErrata,
        isAdvisoryAvailable,
        hasAccess
    } = useAccountStats(isEdgeParityEnabled, setLoading, addNotification);

    const subPath = location.pathname && location.pathname.split('/')[4];

    useEffect(() => {
        chrome.updateDocumentTitle(
            `${subPath ? `${subPath} - ` : ''} ${title} - ${intl.formatMessage(messages.pageTitleSuffix)}`
        );

    }, [chrome, intl, subPath]);

    useEffect(() => {
        chrome.hideGlobalFilter(!globalFilterEnabled);
    }, [location.pathname]);

    if (isLoading) {
        return <PageLoading />;
    }

    return hasAccess
        ? <AsyncComponent
            appId="vulnerability_zero_state"
            appName="dashboard"
            module="./AppZeroState"
            ErrorComponent={<ErrorState />}
            app="Vulnerability"
            aria-label="Zero state"
            customFetchResults={checkForAccountSystems(isEdgeParityEnabled, hasEdgeDevices, hasConventionalSystems)}
            className="pf-v5-u-h-100"
        >
            <AccountStatContext.Provider value={{
                hasConventionalSystems,
                hasEdgeDevices,
                includesCvesWithoutErrata,
                isAdvisoryAvailable
            }}>
                <Element
                    {...elementProps}
                    hasEdgeDevices={hasEdgeDevices}
                    hasConventionalSystems={hasEdgeDevices}
                    aria-label="Insights element"
                />
            </AccountStatContext.Provider>
        </AsyncComponent>
        : <NotAuthorized
            title="This application requires Inventory permissions"
            description={
                <div>
                  To view the content of this page, you must be granted a minimum of
                  inventory permissions from your Organization Administrator.
                </div>
            }
        />;
};

InsightsElement.propTypes = {
    element: PropTypes.func,
    title: PropTypes.string,
    globalFilterEnabled: PropTypes.bool,
    changeTitle: PropTypes.bool
};

export const VulnerabilityRoutes = () => {
    return (
        <Suspense fallback={<PageLoading />}>
            <Routes>
                <Route
                    path={PATHS.cveDetailsPage.to}
                    element={
                        <InsightsElement
                            element={CVEDetailsPage}
                            title={intl.formatMessage(messages.cvesHeader)}
                            globalFilterEnabled
                        />
                    }
                />
                <Route
                    path={PATHS.cveDetailsEdgePage.to}
                    element={
                        <InsightsElement
                            element={CVEDetailsPage}
                            title={intl.formatMessage(messages.cvesHeader)}
                            isImmutableTabOpen
                        />
                    }
                />
                <Route
                    path={PATHS.systemDetailsPage.to}
                    element={<InsightsElement
                        element={SystemDetailsPage}
                        title={intl.formatMessage(messages.systemsHeader)}
                        globalFilterEnabled
                    />
                    }
                />

                <Route
                    path={PATHS.cvesPage.to}
                    element={
                        <InsightsElement
                            element={LandingPage}
                            title={intl.formatMessage(messages.cvesHeader)}
                            globalFilterEnabled
                        />
                    }
                />

                <Route
                    path={PATHS.systemsPage.to}
                    element={
                        <InsightsElement
                            element={SystemsPage}
                            title={intl.formatMessage(messages.systemsHeader)}
                            globalFilterEnabled
                        />
                    }
                />

                <Route
                    path={PATHS.upgrade.to}
                    element={<InsightsElement element={Upgrade} title={intl.formatMessage(messages.upgradePageTitle)} />}
                />

                <Route
                    path={PATHS.reports.to}
                    element={<InsightsElement element={Reports} title={intl.formatMessage(messages.reportsPageTitle)} />}
                />

                <Route
                    path="*"
                    element={<Navigate to="cves" />}
                />
            </Routes>
        </Suspense>
    );
};
