import * as reactCore from '@patternfly/react-core';
import * as reactIcons from '@patternfly/react-icons';
import * as pfReactTable from '@patternfly/react-table';
import { Main } from '@redhat-cloud-services/frontend-components';
import { addNotification } from '@redhat-cloud-services/frontend-components-notifications';
import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/files/helpers';
import propTypes from 'prop-types';
import qs from 'query-string';
import React, { useState, useEffect } from 'react';
import { connect } from 'react-redux';
import * as reactRouterDom from 'react-router-dom';
import { dataShape } from '../../../Helpers/MiscHelper';
import { fetchSystems, optOutSystemsAction, setHeader, selectEntities } from '../../../Store/Actions/Actions';
import { inventoryEntitiesReducer } from '../../../Store/Reducers/InventoryEntitiesReducer';
import { sAllSystems } from '../../../Store/Selectors/CVESelectors';
import ReducerRegistry, { middlewareListener } from '../../../Utilities/ReducerRegistry';
import VulnerabilityHeader from '../VulnerabilityHeader/VulnerabilityHeader';
import {
    kebabItemToggleExcludeSystemDisplay,
    kebabItemExcludeSystemAnalysis
} from '../../PresentationalComponents/DownloadReportKebab/KebabItems';
import './Systems.scss';

import { PrimaryToolbar } from '@redhat-cloud-services/frontend-components';
import { kebabActions, exportConfig } from '../../../Helpers/TableToolbarHelper';
import selectAllCheckbox from '../../../Helpers/selectAllCheckboxHelper';
import searchFilter from '../../PresentationalComponents/Filters/Searchfilter';

/*eslint camelcase: 0*/

const Systems = (props) => {
    const [InventoryCmp, setInventoryCmp] = useState();
    const [selected, setSelected] = useState(new Set());
    const [filter, setFilter] = useState(undefined);
    const [opt_out, setOptOut] = useState(false);
    const [page_size, setPageSize] = useState(10);
    //const [items, setItems] = useState();
    const [page, setPage] = useState(1);
    const [columns] = useState([
        {
            key: 'display_name',
            title: 'Name',
            composed: ['facts.os_release', 'display_name']
        },
        {
            key: 'cve_count',
            title: 'Applicable CVEs'
        }
    ]);

    const onSelect = (payload) => {
        let newSelected;
        if (!payload.data || Array.isArray(payload.data)) {
            newSelected = new Set(payload.data);
        } else {
            newSelected = selected;
            payload.data.selected ? newSelected.add(payload.data.id) : newSelected.delete(payload.data.id);
        }

        setSelected(newSelected);
        props.selectMultiple();
    };

    const [selectListener, setSelectListener] = useState(middlewareListener.addNew({
        on: 'SELECT_ENTITY',
        callback: payload => onSelect(payload)
    }));
    const [selectAllListener, setSelectAllListener] = useState(middlewareListener.addNew({
        on: 'SELECT_ENTITIES',
        callback: payload => onSelect(payload)
    }));

    const getSelected = () => {
        return selected;
    };

    const fetchInventory = async () => {
        const { inventoryConnector, mergeWithEntities, mergeWithDetail } = await insights.loadInventory({
            react: React,
            reactRouterDom,
            reactCore,
            reactIcons,
            pfReactTable
        });
        ReducerRegistry.register({
            ...mergeWithEntities(inventoryEntitiesReducer(columns, getSelected)),
            ...mergeWithDetail()
        });

        const InventoryCmp = inventoryConnector().InventoryTable;
        setInventoryCmp(() => InventoryCmp);
    };

    const createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = ['filter', 'page', 'page_size'];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        props.history.push('?' + queryString);
    };

    const sendRequest = () => {
        const { fetchData } = props;
        fetchData({ filter, page, page_size });
    };

    useEffect(() => {
        const queryObject = qs.parse(props.location.search);
        queryObject.show_irrelevant = queryObject.show_irrelevant === 'true';
        if (queryObject.show_irrelevant) {
            queryObject.show_all = undefined;
        }

        fetchInventory();
        sendRequest();
    }, []);

    const downloadReport = format => {
        const { payload } = fetchSystems({
            opt_out,
            filter,
            data_format: format,
            page: 1,
            page_size: Number.MAX_SAFE_INTEGER
        });
        payload &&
            payload.then(({ data: response }) => {
                const data = format === 'json' ? JSON.stringify(response) : response;
                return downloadFile(data, `systems-${new Date().toISOString()}`, format);
            });
    };

    const doOptOut = () => {
        if (selected.size > 0) {
            props.optOutSystems(selected, !opt_out).then(() => {
                props.fetchData({ ...this.params(), page: 1 });
                this.state.opt_out === false
                    ? props.addNotification({
                        variant: 'success',
                        title: selected.size + ' systems successfully excluded from vulnerability analysis'
                    })
                    : props.addNotification({
                        variant: 'success',
                        title: selected.size + ' systems successfully resumed vulnerability analysis',
                        description: 'There may be 24 hours before data is available'
                    });
                setSelected(new Set());
            });
        }
    };

    const handleRefresh = ({ page, per_page: perPage, filter }) => {
        const { meta } = props.systems;
        const { fetchData } = props;
        if (meta.page !== page || meta.page_size !== perPage) {
            const config = {
                page,
                page_size: perPage || meta.page_size,
                filter,
                opt_out
            };
            fetchData(config);
            createUrlParams(config);
        }
    };

    const fetchResource = ({ page_size, page, filter }) => {
        const { meta } = props.systems;
        if (meta.page !== page || meta.page_size !== page_size) {
            const config = {
                page,
                page_size: page_size || meta.page_size,
                filter,
                opt_out
            };
            return fetchSystems(config);
        }
    };

    const handleOptOut = () => {
        setOptOut(!opt_out);
        setSelected(new Set());
        setPage(1);
        sendRequest;
    };

    const handleSelect = (isChecked, payload) => {
        if (Array.isArray(payload)) {
            payload.forEach(element => selected.add(element));
        }
        else {
            selected.clear();
        }

        props.selectMultiple();
        setSelected(selected);

    };

    const kebabOptions = [
        kebabItemExcludeSystemAnalysis(doOptOut, opt_out, {
            isDisabled: !getSelected().size
        }),
        kebabItemToggleExcludeSystemDisplay(handleOptOut, opt_out)
    ];
    const filterIt = searchFilter('Find a CVE...', handleRefresh, filter);
    const selectOptions = selectAllCheckbox({
        selectedItems: getSelected(),
        selectorHandler: handleSelect,
        items: props.systems,
        fetchResource: ops => fetchResource({ ...ops }),
        multiRow: true
    });

    const { data, meta } = props.systems;
    const items = data.map(item => {
        const { cve_count, ...rest } = item.attributes;
        return {
            cve_count: (meta.opt_out && 'Excluded') || cve_count,
            id: item.attributes.inventory_id,
            ...rest
        };
    });

    if(props.systems){
        return (
            <reactCore.Page>
                <VulnerabilityHeader showBreadcrumb={false} />
                <Main>
                    {InventoryCmp && <InventoryCmp
                        hasCheckbox={data.length !== 0}
                        page={meta.page}
                        total={meta.total_items || 0}
                        perPage={meta.page_size}
                        onRefresh={handleRefresh}
                        items={items}
                    >
                        <PrimaryToolbar
                            bulkSelect={{
                                count: selected.size,
                                items: selectOptions.items,
                                checked: Boolean(selected.size),
                                onSelect: () => selectOptions.handleOnCheckboxChange()
                            }}
                            // actionsConfig={{
                            //     actions: kebabActions(context, !selectedCvesCount, handleCveDescription, 'systems'),
                            //     dropdownProps: { className: 'custom-class' }
                            // }}
                            filterConfig={{
                                items: [
                                    filterIt
                                ]
                            }}
                            exportConfig={exportConfig({ downloadReport })}
                        >
                        </PrimaryToolbar>
                    </InventoryCmp>}
                </Main>
            </reactCore.Page>
        );
    }else return 0;
    
};

Systems.propTypes = {
    fetchData: propTypes.func,
    systems: dataShape,
    optOutSystems: propTypes.func,
    addNotification: propTypes.func,
    selectRows: propTypes.func,
    selectMultiple: propTypes.func,
    history: propTypes.object,
    location: propTypes.object
};

function mapStateToProps(state) {
    return {
        systems: sAllSystems(state)
    };
}

const mapDispatchToProps = dispatch => {
    return {
        setHeader: header => dispatch(setHeader(header)),
        fetchData: options => dispatch(fetchSystems(options)),
        optOutSystems: (systems, status) => dispatch(optOutSystemsAction(systems, status)),
        addNotification: notification => dispatch(addNotification(notification)),
        selectRows: (value, ids) => dispatch(selectEntities(value, ids)),
        selectMultiple: () => dispatch({ type: 'SELECT_MULTIPLE_ENTITIES' })
    };
};

export default reactRouterDom.withRouter(
    connect(
        mapStateToProps,
        mapDispatchToProps
    )(Systems)
);
