import CVEsTable from './CVEsTable';
import toJson from 'enzyme-to-json';
import { VULNERABILITIES_HEADER } from '../../../Helpers/constants';
import { CVETableContext } from './CVEs';
import { createCveListByAccount } from '../../../Helpers/VulnerabilityHelper';
import { handleSortColumn } from '../../../Helpers/MiscHelper';
import { BrowserRouter as Router } from 'react-router-dom';
import { mountWithIntl } from '../../../Helpers/MiscHelper';


jest.mock('../../../Helpers/MiscHelper', () => (
    {
      ...(jest.requireActual('../../../Helpers/MiscHelper')),
      handleSortColumn: jest.fn(),
    }
));

const mockContext = {
    cves: createCveListByAccount({ payload: {
        isLoading: false,
        meta: {
            test: 'test'
        },
        data: [
            {
                type: 'cve',
                id: 'CVE-2019-6454',
                attributes: {
                    business_risk: "Not Defined",
                    business_risk_id: 0,
                    business_risk_text: null,
                    cve_status_id: 2,
                    cve_status_text: "testhello",
                    cvss2_score: null,
                    cvss3_score: "6.500",
                    description: "A new domain bypass",
                    impact: "Moderate",
                    public_date: "2020-06-09T17:00:00+00:00",
                    reporter: 1,
                    rule: null,
                    status: "On-Hold",
                    status_id: 2,
                    status_text: "testhello",
                    synopsis: "CVE-2020-0543",
                    systems_affected: 1,
                    rule: 'testRule'
                }
            }
        ]

    }}),
    params: {},
    selectedCves: ['CVE-2019-6454'],
    openedCves: ['CVE-2019-6454'],
    expandCveDescription: false,
    methods: {
        apply: jest.fn(),
        downloadReport: jest.fn(),
        selectCves: jest.fn(),
        showBusinessRiskModal: jest.fn(),
        showStatusModal: jest.fn(),
        openCves: jest.fn()
    }
};

describe('CVEs: ', () => {
    it('Should match the snapshot', () => {
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={mockContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        ); 
        expect(toJson(wrapper)).toMatchSnapshot();
    });

    it('Should display SkeletonTable during load', () => {
        const testContext = { ...mockContext, cves: { isLoading: true, meta: { test: 'test' }, data: [] } };
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={testContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        expect(wrapper.find('SkeletonTable')).toHaveLength(1);
    });

    it('Should handle empty data list and display EmptyCVEList page', () => {
        const testContext = { ...mockContext, cves: { isLoading: false, meta: { test: 'test' }, data: [] } };
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={testContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        expect(wrapper.find('[id="emptyState.noCveAffects"]')).toHaveLength(1);
    });

    it('Should handle empty sort result and display FilterNotFoundForCVE page', () => {
        const testContext = { ...mockContext, cves: { isLoading: false, meta: { filter: 'test' }, data: [] } };
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={testContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        expect(wrapper.find('[id="emptyState.noMatchingCves"]')).toHaveLength(1);
    });

    it('Should handle empty list when entity prop is set and display EmptyCVEListForSystem page', () => {
        const testContext = { ...mockContext, cves: { isLoading: false, meta: {}, data: [] } };
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={testContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} entity = {{ test: 'test' }} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        expect(wrapper.find('[id="emptyState.noReportedSystem"]')).toHaveLength(1);
    });

    it('Should call selectCves ', () => {
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={mockContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        const { onSelect } = wrapper.find('[contentId="expanded-content"]').props();
        onSelect(null, false, 0);
        expect(mockContext.methods.selectCves).toHaveBeenCalledWith(false, 'CVE-2019-6454');
    });
    
    it('Should call openCves ', () => {
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={mockContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        const { onCollapse } = wrapper.find('[contentId="expanded-content"]').props();
        onCollapse(null, 'rowkey');
        expect(mockContext.methods.openCves).toHaveBeenCalledWith('rowkey');
    });

    it('Should call handleSortColumn ', () => {
        const wrapper = mountWithIntl(
            <Router>
                <CVETableContext.Provider value={mockContext}>
                        <CVEsTable header = {VULNERABILITIES_HEADER} showAllCheckbox/>
                </CVETableContext.Provider>
            </Router>
        );
        const { onSort } = wrapper.find('[contentId="expanded-content"]').props();
        onSort(null, 'testKey', 'testDirection');
        expect(handleSortColumn).toHaveBeenCalledWith( 
            "testKey", 
            "testDirection", 
            [{ key: 'collapse' }, { key: 'checkbox' }, ...VULNERABILITIES_HEADER],
            mockContext.cves.meta.sort,
            expect.any(Function) 
        );
    });
})