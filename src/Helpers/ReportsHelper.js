import React from 'react';
import {
    getCveReportFilters,
    PUBLIC_DATE_OPTIONS,
    RULE_PRESENCE_OPTIONS,
    PDF_REPORT_PER_PAGE,
    KNOWN_EXPLOIT_FILTER_OPTIONS,
    ADVISORY_AVAILABILITY_FILTER_OPTIONS,
    getAffectingFilterOptions
} from './constants';
import { formatDate } from './MiscHelper';
import { intl } from '../Utilities/IntlProvider';
import { Text } from '@react-pdf/renderer';
import styles from '../Components/SmartComponents/Reports/Common/styles';

export const getDefaultFilterData = (shouldUseHybridSystemFilter = false) => ({
    business_risk_id: [],
    status_id: [],
    impact: [],
    publish_date: 'all',
    rule_presence: [],
    cvss_filter: {
        from: 0.0,
        to: 10.0
    },
    known_exploit: [],
    rhel_version: [],
    advisory_available: ['true'],
    tags: [],
    affecting: shouldUseHybridSystemFilter  ? ['rpmdnf', 'edge'] : ['true']
});

export const buildFilters = (filterData, shouldUseHybridSystemFilter = false) => {
    let newValues = {};
    const DEFAULT_FILTER_DATA = getDefaultFilterData(shouldUseHybridSystemFilter);
    const CVE_REPORT_FILTERS = getCveReportFilters(shouldUseHybridSystemFilter);
    const AFFECTING_FILTER_OPTIONS = getAffectingFilterOptions(shouldUseHybridSystemFilter);

    Object.entries(filterData).forEach(([key, value]) => {
        // if the filters value is default don't include it, but show Advisory filter even if the value is default
        if ((DEFAULT_FILTER_DATA[key] === value && key !== 'advisory_available')
            || value.length === 0                                                                // no items selected
            || (Array.isArray(value) && value.length === CVE_REPORT_FILTERS[key]?.items?.length) // all items selected
            || (key === 'cvss_filter' && value.from === 0 && value.to === 10)) {                 // CVSS score default value
            return;
        }

        newValues[key] = { filter: CVE_REPORT_FILTERS[key].title };

        switch (key) {
            case 'status_id':
            case 'business_risk_id':
            case 'impact': {
                const wordArray = value && Array.from(value).map(subvalue =>
                    CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue)
                        ? CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue).label
                        : '');
                newValues[key].values = wordArray.join(', ');
                break;
            }

            case 'publish_date':
                newValues[key].values = PUBLIC_DATE_OPTIONS.find(val => val.value === value).timespan_label;
                break;

            case 'rule_presence':
                newValues[key].values = value.map(
                    checkedValue => RULE_PRESENCE_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'known_exploit':
                newValues[key].values = value.map(
                    checkedValue => KNOWN_EXPLOIT_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'cvss_filter':
                newValues[key].values = value.from.toFixed(1) + ' - ' + value.to.toFixed(1);
                break;

            case 'rhel_version':
                newValues[key].values = value.map(version => `RHEL ${version}`).join(', ');
                break;

            case 'advisory_available':
                newValues[key].values = value.map(
                    checkedValue => ADVISORY_AVAILABILITY_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'affecting':
                newValues[key].values = value.map(
                    checkedValue =>
                        AFFECTING_FILTER_OPTIONS.find(({ value }) => value === checkedValue).value
                ).join(', ');
                break;
            case 'tags':
                newValues[key].values = value;
                break;

            default:
                newValues[key].values = value;
        }
    });

    return newValues;
};

export function constructReportParameters(filterParams, sorterParams) {
    let reportParams = constructFilterParameters(filterParams);
    reportParams.sort = sorterParams;
    return reportParams;
}

export function constructFilterParameters(filterParams) {
    // construct publish date
    let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);
    let from = undefined;
    let to = undefined;

    if (typeof publicEntry !== 'undefined') {
        from = publicEntry.from && formatDate(publicEntry.from);
        to = publicEntry.to && formatDate(publicEntry.to);
    }

    // FIXME contruct should be dynamic
    // construct rest of params
    let newParams = {
        status_id: filterParams.status_id.toString(),
        business_risk_id: filterParams.business_risk_id.toString(),
        impact: filterParams.impact.toString(),
        cvss_from: filterParams.cvss_filter.from,
        cvss_to: filterParams.cvss_filter.to,
        publish_date: filterParams.publish_date,
        public_from: from,
        public_to: to,
        rule_presence: filterParams.rule_presence.toString(),
        known_exploit: filterParams.known_exploit.toString(),
        rhel_version: filterParams.rhel_version.toString(),
        advisory_available: filterParams.advisory_available.toString(),
        tags: filterParams.tags?.map(tag => tag.string).join(','),
        affecting: filterParams.affecting.toString()
    };

    return newParams;
}

export const intlFormatWithBold = (msg, params) => {
    return intl.formatMessage(msg, { ...params, b: (...chunks) => <Text style={styles.bold}>{chunks}</Text> });
};

export const firstPagePDFLength = (data, params) => {
    let { firstPageWithNote, firstPageWithoutNote } = PDF_REPORT_PER_PAGE;
    return data.userNotes || params.rule_presence === 'true' ? firstPageWithNote : firstPageWithoutNote;
};

const getNotImpactingText = (systemCount) =>
    `Not impacting any of your analyzed ${systemCount} RHEL systems`;

const getImpactingOrNotText = (systemCount) =>
    `Not impacting or impacting at least one of your analyzed ${systemCount} RHEL systems`;

const getConsistingText = ({ rpmdnf: conventionalCount, edge: immutableCount }) =>
    `consisting of ${conventionalCount} conventional and ${immutableCount} immutable.`;

const getImpactingAtLeastText = (systemCount, hostType = '') =>
    `impacting at least one of your analyzed ${systemCount} RHEL ${hostType} systems`;

export const getAffectingFilterTexts = (systemCount, systemCountPerType) => ({
    //Only conventional inventory texts
    false: `${getNotImpactingText(systemCount)}.`,
    true: `${getImpactingAtLeastText(systemCount)}.`,
    'true, false': `${getImpactingOrNotText(systemCount)}.`,

    //hybrid inventory filter texts
    none: `${getNotImpactingText(systemCount)}, ${getConsistingText(systemCountPerType)}.`,
    edge: `${getImpactingAtLeastText(systemCountPerType.edge, 'immutable')}.`,
    rpmdnf: `${getImpactingAtLeastText(systemCountPerType.rpmdnf, 'conventional')}.`,
    'rpmdnf, edge': `${getImpactingAtLeastText(systemCount)}, ${getConsistingText(systemCountPerType)}.`,
    'rpmdnf, none': `${getImpactingOrNotText(systemCount)}, ${getConsistingText(systemCountPerType)}.`,
    'edge, none': `${getImpactingOrNotText(systemCount)}, ${getConsistingText(systemCountPerType)}.`
});
