import { ConnectedSystemCves } from './SystemCves';
import toJson from 'enzyme-to-json';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import { BrowserRouter as Router } from 'react-router-dom';
import configureStore from 'redux-mock-store';
import { Provider } from "react-redux";
import { initialState } from '../../../Store/Reducers/SystemCvesStore';
import { act } from "react-dom/test-utils";
import { useSelector } from 'react-redux';
import DownloadReport from '../../../Helpers/DownloadReport';

jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

let state = {
    ...initialState,
    parameters: { },
    cveList: {
        isLoading: false,
        payload: {
            meta: {
                test: 'test',
                patch_access: true
            },
            data: [
                {
                    type: 'cve',
                    id: 'CVE-2019-6454',
                    attributes: {
                        business_risk: "Not Defined",
                        business_risk_id: 0,
                        business_risk_text: null,
                        cve_status_id: 2,
                        cve_status_text: "testhello",
                        cvss2_score: null,
                        cvss3_score: "6.500",
                        description: "A new domain bypass",
                        impact: "Moderate",
                        public_date: "2020-06-09T17:00:00+00:00",
                        reporter: 1,
                        rule: null,
                        status: "On-Hold",
                        status_id: 2,
                        status_text: "testhello",
                        synopsis: "CVE-2020-0543",
                        systems_affected: 1,
                        advisories_list: ['adv-1', 'adv-2'],
                        known_exploit: false
                    }
                }
            ]
        }
    },
    expandedRows: [],
    selectedCves: [],
    unsupported: false,
};

const customMiddleWare = store => next => action => {
    useSelector.mockImplementation(callback => {
        return callback({ SystemCvesStore: state, AppStore: {popup: {}} });
    });
    next(action);
  }
const mockStore = configureStore([customMiddleWare]);
const store = mockStore(initialState);
window.insights = { loadRemediations: jest.fn(), chrome: { getUserPermissions: jest.fn() } }

let wrapper;
beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ SystemCvesStore: initialState, AppStore: {popup: {}} });
    });
    wrapper = mountWithIntl(
        <Provider store={store}>
            <Router>                    
                <ConnectedSystemCves
                    entity={{ id: 'CVE-2020-0543', display_name: 'testName' }}
                    allowedCveActions={['EDIT_STATUS', 'REMEDIATE']}
                />
            </Router>
        </Provider>
    ); 
});

afterEach(() => {
    useSelector.mockClear();
});

describe('SystemCves', () => {

    it('Should dispatch CHANGE_CVE_LIST_PARAMETERS and FETCH_CVE_LIST only once on load', () => {
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'CHANGE_SYSTEM_CVE_LIST_PARAMETERS')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'FETCH_SYSTEM_CVE_LIST')).toHaveLength(1);
    });

    it('Should clear store on unmount', () => {
        wrapper.unmount();
        const dispatchedActions = store.getActions();
        setTimeout(() => {
            expect(dispatchedActions.filter(item => item.type === 'CLEAR_SYSTEM_CVES_STORE')).toHaveLength(1);
        })
    });

    describe('Check errors', () => {
        let wrapperForErrors;
        function renderComponent(customMiddleWareErrors) {
            const mockStoreErrors = configureStore([customMiddleWareErrors]);
            const storeForErrors = mockStoreErrors(initialState);
            wrapperForErrors = mountWithIntl(
                <Provider store={storeForErrors}>
                    <Router>                    
                        <ConnectedSystemCves
                            entity={{ id: 'CVE-2020-0543', display_name: 'testName' }}
                            allowedCveActions={['EDIT_STATUS', 'REMEDIATE']}
                        />
                    </Router>
                </Provider>
            );
        };

        it('Should generate error', () => {
            const customMiddleWareErrors = store => next => action => {
                useSelector.mockImplementation(callback => {
                    return callback({ 
                        SystemCvesStore: {
                            ...initialState,
                            cveList: { isLoading: false, payload: { errors: true, meta: {}, data: [] } }
                        } 
                    });
                });
                next(action);
            }
            renderComponent(customMiddleWareErrors);
            expect(wrapperForErrors.find('[id="error.reload"]')).toBeTruthy();
        });

        it('Should generate EmptyVulnerabilityData', () => {
            const customMiddleWareErrors = store => next => action => {
                useSelector.mockImplementation(callback => {
                    return callback({ 
                        SystemCvesStore: {
                            ...initialState,
                            cveList: { isLoading: false, payload: { errors: { status: 404 }, meta: {}, data: [] } }
                        } 
                    });
                });
                next(action);
            }
            renderComponent(customMiddleWareErrors);
            expect(wrapperForErrors.find('[id="emptyState.noData"]')).toBeTruthy();
        });
    });
    
    it('Should wrap with context provider of shape', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        expect(context).toEqual( 
                {
                    cves: {
                        data: expect.any(Array),
                        meta:  expect.any(Object),
                        isLoading: false,
                        errors: undefined
                    },
                    parameters: {},
                    selectedCves: [],
                    expandedRows: [],
                    isAllExpanded: false,
                    canRemediate: true,
                    canEditStatus: true,
                    methods: {
                        apply: expect.any(Function),
                        downloadReport: expect.any(Function),
                        selectCves: expect.any(Function),
                        fetchResource: expect.any(Function),
                        showStatusModal: expect.any(Function),
                        openCves: expect.any(Function),
                        setColumnModalOpen: expect.any(Function)
                    }
            }
        );
    });

    it('Should dispatch selectCve action on selecting (an) entitiy/entities', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.selectCves(false, ['testId']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_SYSTEM_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_SYSTEM_CVE')[0].payload).toEqual(['testId']);
    });

    it('Should dispatch selectCve action with undefined if no cveNames supplied on selecting (an) entitiy/entities', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.selectCves();
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_SYSTEM_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_SYSTEM_CVE')[0].payload).toEqual(undefined);
    });

    it('Should call Download exec with format and parameters', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.downloadReport('json');

        expect(DownloadReport.exec).toHaveBeenCalled();
    });

    it('Should dispatch openCve action on opening (an) entitiy/entities', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.openCves(['testID']);
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_SYSTEM_CVE')).toHaveLength(1);
    });

    it('Should dispatch changeParameters action on apply method call with provided parameters', async () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.apply({ test: 'testString '});
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_SYSTEM_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({ test: 'testString '});        
        expect(action).toHaveLength(2);
    });

    it('Should apply method set filterParams to default {} when no parameter supplied', async () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        context.methods.apply();
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_SYSTEM_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({});          
        expect(action).toHaveLength(2);
    });

    it('Should display status modal', () => {
        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        act(() => context.methods.showStatusModal([{ id: 'CVE-2019-6454' }])); // id of selected CVE
        wrapper.update();
        const modal = wrapper.find('CvePairStatusModal');
        const { cveList } = modal.props();
        expect(modal).toBeTruthy();
        expect(cveList).toEqual([{
            id: 'CVE-2019-6454',
            status_id: 'testStatusId',
            cve_justification: "testhello",
            cve_status_id: 2,
            status_id: "testStatusId",
            justification: "testhello",
            status_id: 2
        }]);
    });

    it('Should detect if cveList has different status in status modal', () => {
        state.cveList.payload.data =  [
            ...state.cveList.payload.data,
            {
                type: 'cve',
                id: 'CVE-2019-6455',
                attributes: {
                    business_risk: "Not Defined",
                    business_risk_id: 0,
                    business_risk_text: null,
                    cve_status_id: 2,
                    cve_status_text: "testhello",
                    cvss2_score: null,
                    cvss3_score: "6.500",
                    description: "A new domain bypass",
                    impact: "Moderate",
                    public_date: "2020-06-09T17:00:00+00:00",
                    reporter: 1,
                    rule: null,
                    status: "On-Hold",
                    status_id: 3,
                    status_text: "testhello",
                    synopsis: "CVE-2020-0543",
                    systems_affected: 1,
                    known_exploit: false
                }
            }
        ];

        const { context } = wrapper.find('SystemCvesTableWithContext').props();
        act(() => context.methods.showStatusModal([{ id: 'CVE-2019-6454', status_id: 3 }, { id: 'CVE-2019-6455', status_id: 1 }]));
        wrapper.update();
        const modal = wrapper.find('CvePairStatusModal');
        expect(modal).toBeTruthy();
    });
});