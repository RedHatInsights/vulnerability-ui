/* eslint-disable camelcase */
import { Stack, StackItem } from '@patternfly/react-core';
import { classNames, sortable } from '@patternfly/react-table';
import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/files/helpers';
import propTypes from 'prop-types';
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { CVSSOptions, GenericError, NoVulnerabilityData, PublicDateOptions } from '../../../Helpers/constants';
import { createCveListBySystem } from '../../../Helpers/VulnerabilitiesHelper';
import { fetchCveListBySystem } from '../../../Store/Actions/Actions';
import '../CVEs/vulnerabilities.scss';
import StatusDropdown from '../StatusDropdown/StatusDropdown';
import SystemCveTable from './SystemCveTable';
import SystemCveTableToolbar from './SystemCveTableToolbar';
import qs from 'query-string';
import { withRouter } from 'react-router-dom';

export const CVETableContext = React.createContext({});

const header = [
    {
        title: 'Name',
        key: 'synopsis',
        transforms: [sortable, classNames('col-width-10')],
        columnTransforms: [classNames('no-wrap')]
    },
    {
        title: 'Description',
        key: 'description',
        transforms: [classNames('col-width-description')],
        columnTransforms: [classNames('hide-description')]
    },
    {
        title: 'Publish date',
        key: 'public_date',
        transforms: [sortable, classNames('col-width-10')]
    },
    {
        title: 'CVSS base ',
        key: 'cvss_score',
        transforms: [sortable, classNames('col-width-10')]
    },
    {
        title: 'Impact',
        key: 'impact',
        transforms: [sortable, classNames('col-width-10')],
        columnTransforms: [classNames('no-wrap')]
    },
    { title: 'Status', key: 'status', transforms: [sortable, classNames('col-width-15')] }
];

class SystemCves extends Component {
    static propTypes = {
        entity: propTypes.object,
        cveList: propTypes.any,
        fetchData: propTypes.func,
        history: propTypes.object,
        location: propTypes.object
    };

    constructor(props) {
        super(props);
        this.state = { selectedCves: new Set() };
    }

    componentDidMount() {
        StatusDropdown.setCallback(this.sendRequest);
        const defaultParams = { sort: '-public_date' };
        const queryObject = qs.parse(this.props.location.search);
        this.apply({ ...defaultParams, ...queryObject });
    }

    processError = error => {
        const { status } = error;
        const statusCode = parseInt(status);
        if (statusCode === 404 && this.props.entity) {
            return NoVulnerabilityData;
        } else {
            return GenericError;
        }
    };

    apply = (config = {}) => {
        if (config.hasOwnProperty('cvss_filter')) {
            let cvssEntry = CVSSOptions.find(item => item.value === config.cvss_filter);
            if (!cvssEntry) {
                let values = config.cvss_filter.split(/[^0-9]+/).filter(item => parseFloat(item));
                cvssEntry = { value: config.cvss_filter, from: values[0], to: values[1] };
            }

            config.cvss_from = cvssEntry.from;
            config.cvss_to = cvssEntry.to;
        }

        if (config.hasOwnProperty('publish_date')) {
            let publicEntry = PublicDateOptions.find(item => item.value === config.publish_date);
            config.public_from = publicEntry.from && publicEntry.from.format('YYYY-MM-DD');
            config.public_to = publicEntry.to && publicEntry.to.format('YYYY-MM-DD');
        }

        this.setState({ ...this.state, ...config }, this.sendRequest);
    };

    selectCves = (isSelected, cveNames) => {
        let { selectedCves } = this.state;
        if (cveNames) {
            [].concat(cveNames).forEach(cveName => {
                isSelected ? selectedCves.add(cveName) : selectedCves.delete(cveName);
            });
        } else {
            selectedCves = new Set();
        }

        this.setState({ ...this.state, selectedCves: new Set(selectedCves) });
    };

    createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = [
            'cvss_filter',
            'publish_date',
            'filter',
            'limit',
            'offset',
            'page',
            'page_size',
            'sort',
            'impact'
        ];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        this.props.history.push('?' + queryString);
    };

    sendRequest = () => {
        const { fetchData, entity } = this.props;
        fetchData && fetchData({ ...this.state, system: entity.id });
        this.createUrlParams(this.state);
    };

    downloadReport = format => {
        const params = { ...this.state };
        let { payload } = fetchCveListBySystem({ ...params, page_size: Number.MAX_SAFE_INTEGER, data_format: format, page: 1 });
        payload &&
            payload.then(({ data: response }) => {
                const data = format === 'json' ? JSON.stringify(response) : response;
                return downloadFile(data, `vulnerability_cves-${new Date().toISOString()}`, format);
            });
    };

    render() {
        const { cveList, entity } = this.props;
        const { apply, downloadReport, selectCves } = this;
        const cves = createCveListBySystem(entity.id, cveList);
        const { errors } = cves;
        if (!errors) {
            return (
                <CVETableContext.Provider
                    value={{
                        cves,
                        params: this.state,
                        methods: {
                            apply,
                            downloadReport,
                            selectCves,
                            fetchResource: params => fetchCveListBySystem({ ...params, system: entity.id })
                        }
                    }}
                >
                    <Stack>
                        <StackItem>
                            <SystemCveTableToolbar showRemediationButton entity={entity} />
                        </StackItem>
                        <StackItem>
                            <SystemCveTable header={header} isSelectable entity={entity} />
                        </StackItem>
                    </Stack>
                </CVETableContext.Provider>
            );
        } else {
            return this.processError(errors);
        }
    }
}

function mapStateToProps({ SystemCvesStore, entityDetails: { entity } }) {
    return {
        cveList: SystemCvesStore && SystemCvesStore.cveList,
        entity
    };
}

const mapDispatchToProps = dispatch => {
    return {
        fetchData: params => dispatch(fetchCveListBySystem(params))
    };
};

export default withRouter(
    connect(
        mapStateToProps,
        mapDispatchToProps
    )(SystemCves)
);
