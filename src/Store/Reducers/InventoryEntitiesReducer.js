import { selectRows } from './reducersHelper';
import * as ActionTypes from '../ActionTypes';
import unionBy from 'lodash/unionBy';

export const initialState = {
    columns: [],
    rows: [],
    entities: [],
    meta: {
        page: 1,
        page_size: 20
    },
    selectedRows: {},
    prevLoadedRows: [],
    selectedRowsRawData: [],
    selectedRowsCount: 0
};

function modifyInventory(columns, state, action) {
    let advisory = columns.find(({ key }) => key === 'advisory');

    if (!state.selectedRows) {
        state.selectedRows = {};
    }

    if (!state.sortBy) {
        state.sortBy = {
            key: 'updated',
            direction: 'desc'
        };
    }

    if (state.loaded) {
        let hasPatchAccess = state.rows.some(({ patchAccess }) => patchAccess);

        if (!hasPatchAccess && advisory) {
            advisory.isShown = false;
        }

        return {
            ...state,
            columns,
            rows: state.rows.map(row => ({
                ...row,
                selected: state.selectedRows[row.id] || false
            })),
            prevLoadedRows: unionBy(action.payload.results, state.prevLoadedRows, 'id'),
            meta: action.payload.meta
        };
    }

    return state;
}

export const inventoryEntitiesReducer = (columns) => (state = initialState, action) => {
    switch (action.type) {
        case 'LOAD_ENTITIES_FULFILLED':
            return modifyInventory(columns, state, action);
        case ActionTypes.SELECT_ENTITY:
            return selectRows(state, action);
        case 'EXPAND_ROW':
            return {
                ...state,
                rows: state.rows.map(row => ({
                    ...row,
                    isOpen: row.id === action.payload.id ? action.payload.isOpen : row.isOpen
                }))
            };
        case 'CLEAR_INVENTORY_STORE':
            return initialState;
        default:
            return state;
    }
};
