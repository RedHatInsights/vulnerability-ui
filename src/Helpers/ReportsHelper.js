import React from 'react';
import {
    getCveReportFilters,
    PUBLIC_DATE_OPTIONS,
    RULE_PRESENCE_OPTIONS,
    DEFAULT_FILTER_DATA,
    PDF_REPORT_PER_PAGE,
    KNOWN_EXPLOIT_FILTER_OPTIONS,
    ADVISORY_AVAILABILITY_FILTER_OPTIONS
} from './constants';
import { formatDate } from './MiscHelper';
import { intl } from '../Utilities/IntlProvider';
import { Text } from '@react-pdf/renderer';
import styles from '../Components/SmartComponents/Reports/Common/styles';

export const buildFilters = (filterData, isEdgeParityEnabled = false) => {
    let newValues = {};
    const CVE_REPORT_FILTERS = getCveReportFilters(isEdgeParityEnabled);
    Object.entries(filterData).forEach(([key, value]) => {
        // if the filters value is default don't include it, but show Advisory filter even if the value is default
        if ((DEFAULT_FILTER_DATA[key] === value && key !== 'advisory_available')
            || value.length === 0                                                                // no items selected
            || (Array.isArray(value) && value.length === CVE_REPORT_FILTERS[key]?.items?.length) // all items selected
            || (key === 'cvss_filter' && value.from === 0 && value.to === 10)) {                 // CVSS score default value
            return;
        }

        newValues[key] = { filter: CVE_REPORT_FILTERS[key].title };

        switch (key) {
            case 'status_id':
            case 'business_risk_id':
            case 'impact': {
                const wordArray = value && Array.from(value).map(subvalue =>
                    CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue)
                        ? CVE_REPORT_FILTERS[key]?.items.find(val => val.value === subvalue).label
                        : '');
                newValues[key].values = wordArray.join(', ');
                break;
            }

            case 'publish_date':
                newValues[key].values = PUBLIC_DATE_OPTIONS.find(val => val.value === value).timespan_label;
                break;

            case 'rule_presence':
                newValues[key].values = value.map(
                    checkedValue => RULE_PRESENCE_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'known_exploit':
                newValues[key].values = value.map(
                    checkedValue => KNOWN_EXPLOIT_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'cvss_filter':
                newValues[key].values = value.from.toFixed(1) + ' - ' + value.to.toFixed(1);
                break;

            case 'rhel_version':
                newValues[key].values = value.map(version => `RHEL ${version}`).join(', ');
                break;

            case 'advisory_available':
                newValues[key].values = value.map(
                    checkedValue => ADVISORY_AVAILABILITY_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'tags':
                newValues[key].values = value;
                break;

            default:
                newValues[key].values = value;
        }
    });

    return newValues;
};

export function constructReportParameters(filterParams, sorterParams) {
    let reportParams = constructFilterParameters(filterParams);
    reportParams.sort = sorterParams;
    return reportParams;
}

export function constructFilterParameters(filterParams) {
    // construct publish date
    let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);
    let from = undefined;
    let to = undefined;

    if (typeof publicEntry !== 'undefined') {
        from = publicEntry.from && formatDate(publicEntry.from);
        to = publicEntry.to && formatDate(publicEntry.to);
    }

    // FIXME contruct should be dynamic
    // construct rest of params
    let newParams = {
        status_id: filterParams.status_id.toString(),
        business_risk_id: filterParams.business_risk_id.toString(),
        impact: filterParams.impact.toString(),
        cvss_from: filterParams.cvss_filter.from,
        cvss_to: filterParams.cvss_filter.to,
        publish_date: filterParams.publish_date,
        public_from: from,
        public_to: to,
        rule_presence: filterParams.rule_presence.toString(),
        known_exploit: filterParams.known_exploit.toString(),
        rhel_version: filterParams.rhel_version.toString(),
        advisory_available: filterParams.advisory_available.toString(),
        tags: filterParams.tags?.map(tag => tag.string).join(',')
    };

    return newParams;
}

export const intlFormatWithBold = (msg, params) => {
    return intl.formatMessage(msg, { ...params, b: (...chunks) => <Text style={styles.bold}>{chunks}</Text> });
};

export const firstPagePDFLength = (data, params) => {
    let { firstPageWithNote, firstPageWithoutNote } = PDF_REPORT_PER_PAGE;
    return data.userNotes || params.rule_presence === 'true' ? firstPageWithNote : firstPageWithoutNote;
};
