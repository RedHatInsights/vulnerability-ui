import union from 'lodash/union';
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { useIntl } from 'react-intl';
import {
    addNotification as addNotificationFEC,
    clearNotifications as clearNotificationsFEC
} from '@redhat-cloud-services/frontend-components-notifications/redux';
import { optOutSystemsAction } from '../../src/Store/Actions/Actions';
import messages from '../Messages';

export const useNotification = (config) => {
    const dispatch = useDispatch();

    const globalConfig = {
        variant: 'info',
        ...config
    };

    useEffect(() => {
        return () => {
            if (!config.preventClear) {
                dispatch(clearNotificationsFEC());
            }
        };
    }, [dispatch]);

    const addNotification = ({ msg, ...config }) =>
        dispatch(
            addNotificationFEC({
                title: msg,
                ...globalConfig,
                ...config
            })
        );

    const clearNotifications = () =>
        dispatch(clearNotificationsFEC());

    return [addNotification, clearNotifications];
};

export const useGetEntities = (fetchApi, { id, setUrlParams, createRows }) => {
    const getEntities = async (
        _items,
        { orderBy, orderDirection, page, per_page: perPage, vulnerabilityParams }
    ) => {
        const sort = `${orderDirection === 'ASC' ? '' : '-'}${orderBy}`;

        const params = {
            ...vulnerabilityParams,
            page,
            page_size: perPage,
            sort
        };

        setUrlParams({ ...params });

        const items = await fetchApi(
            {
                ...id && { id },
                ...params
            }
        );

        return {
            results: typeof createRows === 'function'
                ? createRows({ items, cveId: id })
                : items?.data?.map(row => ({ id: row.id, ...row.attributes })),
            total: items?.meta?.total_items,
            meta: items?.meta
        };
    };

    return getEntities;
};

export const useOptOutSystems = onRefreshInventory => {
    const [addSuccessNotification] = useNotification({ variant: 'success' });
    const [addFailureNotification] = useNotification({ variant: 'danger', autoDismiss: false });
    const dispatch = useDispatch();
    const intl = useIntl();

    /**
     * Excludes/included provided system(s), if toggling one system systemId and systemName have to be set.
     * If toggling multiple systems, these two params are ignored and system info will be extracted from selectedRows.
     * @param {object} affectedRows - object with keys representing ids of systems to opt out/in
     * @param {?string} systemName - display name of a system if only a single system is toggled
     * @param {bool} isIncluded - if true systems will be excluded, else included
     */
    return (affectedRows, systemName, isIncluded) => {
        const count = Object.keys(affectedRows).length;

        dispatch(optOutSystemsAction(Object.keys(affectedRows), isIncluded))
        .then(() => {
            isIncluded ?
                addSuccessNotification({
                    msg: intl.formatMessage(messages.notificationExcludeSuccess, { count, systemName }) })
                : addSuccessNotification({
                    msg: intl.formatMessage(messages.notificationIncludeSuccessTitle, { count, systemName }),
                    description: intl.formatMessage(messages.notificationIncludeSuccessBody)
                });
        }).catch(() => {
            isIncluded ?
                addFailureNotification({
                    msg: intl.formatMessage(messages.notificationExcludeFailureTitle, { count, systemName }),
                    description: intl.formatMessage(messages.notificationExcludeFailureBody, { count }) })
                : addFailureNotification({
                    msg: intl.formatMessage(messages.notificationIncludeFailureTitle, { count, systemName }),
                    description: intl.formatMessage(messages.notificationIncludeFailureBody, { count })
                });
        }).finally(onRefreshInventory);
    };
};

const mapSelectedRows = ({ id }) => ({ id, selected: true });

export const useBulkSelect = ({ rawData, selectedRows, selectedRowsCount, handleSelect, fetchResource, multiRow = false }) => {
    const intl = useIntl();
    const { meta, data } = rawData;

    const selectPageNumber = data && (((Array.isArray(data) && data.length) && multiRow) ? data.length / 2 : data.length);

    const handleSelectPage = () => {
        const { data } = rawData ?? {};
        const collectedRows = data && union(
            data.filter(item => item.id).map(mapSelectedRows),
            Object.values(selectedRows)
        );

        handleSelect(collectedRows);
    };

    const handleUnselect = () => handleSelect([]);

    const handleSelectAll = async () => {

        let { payload } = await fetchResource({ page_size: meta?.total_items, page: 1 });

        payload.then(({ data }) => {
            handleSelect(data.map(mapSelectedRows));
        });
    };

    return {
        count: selectedRowsCount,
        checked: Boolean(selectedRowsCount),
        isDisabled: meta.total_items === 0 && selectedRowsCount === 0,
        ouiaId: 'bulk-select',
        items: [
            {
                title: intl.formatMessage(messages.selectNone),
                onClick: handleUnselect
            },
            {
                title: `${intl.formatMessage(messages.selectPage, { count: selectPageNumber })}`,
                onClick: handleSelectPage
            },
            {
                title: `${intl.formatMessage(messages.selectAll, { count: meta.total_items ? meta.total_items : 0 })}`,
                onClick: handleSelectAll
            }
        ]

    };

};
