
import React, { useState, useEffect } from 'react';
import propTypes from 'prop-types';
import { useIntl } from 'react-intl';
import { DownloadButton, CSAwIcon } from '@redhat-cloud-services/frontend-components-pdf-generator';
import { getCveListByAccount, getSystems } from '../../../Helpers/APIHelper';
import messages from '../../../Messages';
import firstPagePDF from './Common/firstPagePDF';
import tablePage from './Common/tablePage';
import DownloadReport from '../../../Helpers/DownloadReport';
import { PDF_REPORT_PER_PAGE, STATUS_OPTIONS, BUSINESS_RISK_OPTIONS, impactList } from '../../../Helpers/constants';
import { Text, View } from '@react-pdf/renderer';
import styles from './Common/styles';
import { useDispatch } from 'react-redux';
import { addNotification, clearNotifications } from '@redhat-cloud-services/frontend-components-notifications/cjs/actions';

const DownloadCVEsReport = ({
    filters,
    params,
    reportData = {},
    buttonProps,
    isReportDynamic = false,
    type,
    label,
    ...props
}) => {
    const intl = useIntl();
    const [loading, setLoading] = useState(false);
    const [securityRulesPresent, setSecurityRulesPresent] = useState(false);
    const dispatch = useDispatch();

    useEffect(() => {
        return () => {
            dispatch(clearNotifications());
        };
    }, [dispatch]);

    const otherPagesPDF = data =>
        data.reduce((resultArray, item, index) => {
            const chunkIndex = Math.floor(index / PDF_REPORT_PER_PAGE.otherPages);
            !resultArray[chunkIndex] && (resultArray[chunkIndex] = []);
            resultArray[chunkIndex].push(item);

            return resultArray;
        }, []);

    const cvesFetch = async () => {
        setLoading(true);

        dispatch(addNotification({
            dismissable: true,
            variant: 'info',
            title: intl.formatMessage(messages.customReportNotificationCve)
        }));

        let { data, meta } = await getCveListByAccount({
            ...params,
            ...DownloadReport.defaultParams,
            sort: params.sort || '-cvss_score',
            affecting: 'true,false'
        });

        let user;
        if (reportData && reportData.userNotes) {
            user = await insights.chrome.auth.getUser();
        }

        data = data.map(cve => ({
            ...cve,
            attributes: {
                ...cve.attributes,
                status: STATUS_OPTIONS.find(item =>
                    item.value === cve.attributes.status_id.toString()).label,
                business_risk: BUSINESS_RISK_OPTIONS.find(item =>
                    item.value === cve.attributes.business_risk_id.toString()).label,
                impact: impactList[cve.attributes.impact]?.title || intl.formatMessage(messages.impactListUnknown),
                cvss_score: parseFloat(cve.attributes.cvss3_score || cve.attributes.cvss2_score).toFixed(1)
            }
        }));

        setSecurityRulesPresent(() => {
            const hasRule = data.some(cve => cve.attributes.rules.length > 0);
            return isReportDynamic ? hasRule && reportData && reportData.header?.includes('rule_presence') : hasRule;
        });

        const firstPage = firstPagePDF({
            data: data.splice(0, reportData.userNotes
                ? PDF_REPORT_PER_PAGE.firstPageWithNote
                : PDF_REPORT_PER_PAGE.firstPageWithoutNote),
            meta, filters, intl, isReportDynamic, reportData, user, type
        });

        const otherPages = otherPagesPDF(data);

        setLoading(false);

        return [firstPage, ...otherPages.map((cvePage, index) =>
            tablePage({ data: cvePage, page: index, intl, header: reportData && reportData.header, type, isReportDynamic }))];
    };

    const systemsFetch = async () => {
        setLoading(true);

        dispatch(addNotification({
            dismissable: true,
            variant: 'info',
            title: intl.formatMessage(messages.customReportNotificationSystem)
        }));

        let { data, meta } = await getSystems({
            ...params,
            ...DownloadReport.defaultParams
        });

        const firstPage = firstPagePDF({ data: data.splice(0, PDF_REPORT_PER_PAGE.firstPageWithoutNote), meta, filters, intl });

        const otherPages = otherPagesPDF(data);

        setLoading(false);

        return [firstPage, ...otherPages.map((systemPage, index) =>
            tablePage({ data: systemPage, page: index, intl, header: reportData && reportData.header }))];
    };

    return (
        <div>
            <DownloadButton
                {...props}
                label={loading ? intl.formatMessage(messages.loading) : intl.formatMessage(label)}
                asyncFunction={type === 'cves' ? cvesFetch : systemsFetch}
                buttonProps={{ component: 'button', ...buttonProps }}
                reportName={isReportDynamic ? reportData.reportTitle : (type === 'cves')
                    ? intl.formatMessage(messages.cvePDFReportName)
                    : intl.formatMessage(messages.systemPDFReportName)}
                type={''}
                fileName={`${DownloadReport.filename(type === 'cves' ? (isReportDynamic ? 'reports' : '') : 'system-list')}.pdf`}
                allPagesHaveTitle={false}
                size={'A4'}
                orientation={'landscape'}
                footer={
                    securityRulesPresent && (
                        <View style={styles.footer}>
                            <Text>*</Text>
                            <CSAwIcon style={styles.footerIcon}/>
                            <Text style={styles.footerText}>
                                {intl.formatMessage(messages.customReportFooter)}
                            </Text>
                        </View>)
                }
            />
        </div>
    );
};

DownloadCVEsReport.defaultProps = {
    label: messages.kebabExportAsPDF
};

DownloadCVEsReport.propTypes = {
    filters: propTypes.oneOfType([
        propTypes.array,
        propTypes.object
    ]),
    params: propTypes.object,
    reportData: propTypes.object,
    buttonProps: propTypes.object,
    label: propTypes.oneOfType([
        propTypes.array,
        propTypes.object
    ]),
    isReportDynamic: propTypes.bool,
    type: propTypes.string
};

export default DownloadCVEsReport;
