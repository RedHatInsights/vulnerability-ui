import React, { Component, Fragment } from 'react';
import qs from 'query-string';
import propTypes from 'prop-types';
import { connect } from 'react-redux';
import { withRouter } from 'react-router-dom';
import { injectIntl, IntlProvider } from 'react-intl';
import { SYSTEM_DETAILS_HEADER } from '../../../Helpers/constants';
import { Stack, StackItem, Text, TextContent, TextVariants } from '@patternfly/react-core';

import { EmptyVulnerabilityData, GenericError } from '../../PresentationalComponents/EmptyStates/EmptyStates';
import { createCveListBySystem } from '../../../Helpers/VulnerabilitiesHelper';
import { CVSSOptions, PublicDateOptions } from '../../../Helpers/constants';
import { fetchCveListBySystem } from '../../../Store/Actions/Actions';
import { updateStateSet } from '../../../Helpers/MiscHelper';
import DownloadReport from '../../../Helpers/DownloadReport';
import CvePairStatusModal from '../Modals/CvePairStatusModal';
import SystemCveTableToolbar from './SystemCveTableToolbar';
import SystemCveTable from './SystemCveTable';
import messages from '../../../Messages';

import '../CVEs/vulnerabilities.scss';

export const CVETableContext = React.createContext({});

class SystemCves extends Component {
    static propTypes = {
        entity: propTypes.object,
        cveList: propTypes.any,
        fetchData: propTypes.func,
        history: propTypes.object,
        location: propTypes.object,
        intl: propTypes.any
    };

    constructor(props) {
        super(props);
        this.state = {
            selectedCves: new Set(),
            openedCves: new Set(),
            StatusModal: () => null,
            expandCveDescription: false
        };
    }

    componentDidMount() {
        const defaultParams = { sort: '-public_date' };
        const queryObject = qs.parse(this.props.location.search);
        this.apply({ ...defaultParams, ...queryObject });
    }

    processError = error => {
        const { status } = error;
        const statusCode = parseInt(status);
        if (statusCode === 404 && this.props.entity) {
            return EmptyVulnerabilityData;
        } else {
            return GenericError;
        }
    };

    dataReload = () => {
        const { meta, data } = this.props.cveList;
        const { page, pages } = meta;
        const reloadPage = page === pages && data.length / 2 === 1 ? 1 : page;

        this.setState(
            {
                ...this.state,
                page: reloadPage,
                page_size: meta.page_size
            },
            this.apply
        );
    }

    apply = (config = {}) => {

        if (Object.prototype.hasOwnProperty.call(config, 'cvss_filter')) {
            let cvssEntry = CVSSOptions.find(item => item.value === config.cvss_filter);

            if (typeof cvssEntry === 'undefined' && typeof config.cvss_filter !== 'undefined') {
                let values = config.cvss_filter.split(/[^0-9]+/).filter(item => parseFloat(item));
                cvssEntry = { from: values[0], to: values[1] };
            } else if (typeof cvssEntry === 'undefined' && typeof config.cvss_filter === 'undefined') {
                cvssEntry = { from: undefined, to: undefined };
            }

            config.cvss_from = cvssEntry.from;
            config.cvss_to = cvssEntry.to;
        }

        if (Object.prototype.hasOwnProperty.call(config, 'publish_date')) {
            let publicEntry = PublicDateOptions.find(item => item.value === config.publish_date);

            if (typeof publicEntry !== 'undefined') {
                config.public_from = publicEntry.from && publicEntry.from.format('YYYY-MM-DD');
                config.public_to = publicEntry.to && publicEntry.to.format('YYYY-MM-DD');
            } else {
                config.public_from = undefined;
                config.public_to = undefined;
                config.publish_date = undefined;
            }
        }

        this.setState({ ...this.state, ...config }, this.sendRequest);
    };

    selectCves = (isSelected, cveNames) => {
        let { selectedCves } = this.state;
        if (cveNames) {
            selectedCves = updateStateSet(selectedCves, cveNames, isSelected);
        } else {
            selectedCves = new Set();
        }

        this.setState({ ...this.state, selectedCves: new Set(selectedCves) });
    };

    // @TODO System has different mechanism to store opened, unify the mechanism with CVE
    openCves = (isOpen, cveNames, isExpanded) => {
        let { openedCves, expandCveDescription } = this.state;

        // if expanded, collapse rows
        if (expandCveDescription && !cveNames.length) {
            openedCves = cveNames;
        }

        if (cveNames) {
            openedCves = updateStateSet(openedCves, cveNames, isOpen);
        } else {
            openedCves = new Set();
        }

        if (!Array.isArray(cveNames)) {
            const visibleCves = this.props.cveList.data;
            const visibleOpenedCves = visibleCves.filter(cve => openedCves.has(cve.id));

            isExpanded = (visibleCves.length / 2 === visibleOpenedCves.length);
        }

        this.setState({ ...this.state, openedCves: new Set(openedCves), expandCveDescription: isExpanded });
    };

    createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = [
            'cvss_filter',
            'publish_date',
            'filter',
            'limit',
            'offset',
            'page',
            'page_size',
            'sort',
            'impact',
            'business_risk_id',
            'status_id',
            'security_rule'
        ];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        this.props.history.push('?' + queryString);
    };

    sendRequest = () => {
        const { fetchData, entity } = this.props;
        const { expandCveDescription } = this.state;
        fetchData && fetchData({ ...this.state, system: entity.id })
        .then(({ data }) => {
            if (expandCveDescription) {
                const cveIds = data && data.map(cve => cve.id);
                this.openCves(true, cveIds, expandCveDescription);
            }
        });
        this.createUrlParams(this.state);
    };

    downloadReport = format => {
        const { entity } = this.props;
        const params = { ...this.state, system: entity.id };
        DownloadReport.exec(fetchCveListBySystem, params, format, 'system-cves');
    };

    showStatusModal = cves => {

        let hasDifferentStatus;
        if (cves.length > 1) {
            const selectedCves = Array.from(this.props.cveList.data.filter(cve => cves.some(element => element.id === cve.id)));

            hasDifferentStatus = selectedCves.some(element => {
                return selectedCves.filter(cve => cve.status_id === element.status_id).length > 1 ? false : true;
            });
        }

        this.setState({
            StatusModal: () => (
                <CvePairStatusModal
                    cves={cves}
                    updateRef={this.dataReload}
                    inventories={[{ id: this.props.entity && this.props.entity.id }]}
                    hasDifferentStatus={hasDifferentStatus}
                    type={'systemDetail'}
                />
            )
        });
    };

    render() {
        const { cveList, entity } = this.props;
        const { apply, downloadReport, selectCves, openCves, showStatusModal } = this;
        const { StatusModal } = this.state;
        const cves = cveList;
        const { errors } = cves;

        if (!errors) {
            return (
                <CVETableContext.Provider
                    value={{
                        cves,
                        params: this.state,
                        methods: {
                            apply,
                            downloadReport,
                            selectCves,
                            openCves,
                            showStatusModal,
                            fetchResource: params => fetchCveListBySystem({ ...params, system: entity.id })
                        }
                    }}
                >
                    <StatusModal />

                    <Stack>
                        <StackItem>
                            <TextContent>
                                <Text component={TextVariants.h2}>
                                    {this.props.intl.formatMessage(messages.systemCvesTableHeader)}
                                </Text>
                            </TextContent>
                        </StackItem>
                        <StackItem>
                            <SystemCveTableToolbar showRemediationButton entity={entity} />
                        </StackItem>
                        <StackItem>
                            <SystemCveTable header={SYSTEM_DETAILS_HEADER} entity={entity} />
                        </StackItem>
                    </Stack>
                </CVETableContext.Provider>
            );
        } else {
            return this.processError(errors);
        }
    }
}

function mapStateToProps({ SystemCvesStore, entityDetails: { entity } }) {
    return {
        cveList: SystemCvesStore && createCveListBySystem(entity.id, SystemCvesStore.cveList),
        entity
    };
}

const mapDispatchToProps = dispatch => {
    return {
        fetchData: params => {
            const cvePromise = fetchCveListBySystem(params);
            dispatch(cvePromise);
            return cvePromise.payload;
        }
    };
};

export const ConnectedSystemCves = withRouter(
    injectIntl(
        connect(
            mapStateToProps,
            mapDispatchToProps
        )(SystemCves)
    )
);

const TranslateSystemCves = ({ customItnlProvider, ...props }) => {
    const {
        Wrapper,
        intlProps
    } = customItnlProvider ? {
        Wrapper: IntlProvider,
        intProps: {
            locale: navigator.language.slice(0, 2),
            messages
        }
    } : {
        wrapper: Fragment,
        intlProps: {}
    };
    return <Wrapper {...intlProps} >
        <ConnectedSystemCves { ...props } />
    </Wrapper>;
};

TranslateSystemCves.propTypes = {
    customItnlProvider: propTypes.bool
};

TranslateSystemCves.defaultProps = {
    customItnlProvider: false
};

export default TranslateSystemCves;
