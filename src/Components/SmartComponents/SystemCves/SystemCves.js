import {
    fetchCveListBySystem,
    changeSystemCVEsParameters,
    selectSystemCve,
    expandSystemCve
} from '../../../Store/Actions/Actions';
import qs from 'query-string';
import propTypes from 'prop-types';
import '../CVEs/vulnerabilities.scss';
import messages from '../../../Messages';
import { withRouter } from 'react-router-dom';
import SystemCveTable from './SystemCveTable';
import { injectIntl, IntlProvider } from 'react-intl';
import { useDispatch, useSelector } from 'react-redux';
import { SYSTEM_DETAILS_HEADER } from '../../../Helpers/constants';
import { CVSSOptions, PublicDateOptions } from '../../../Helpers/constants';
import { createCveListBySystem } from '../../../Helpers/VulnerabilitiesHelper';
import React, { useMemo, useEffect, Fragment, createContext, useState } from 'react';
import { Stack, StackItem, Text, TextContent, TextVariants } from '@patternfly/react-core';
import { EmptyVulnerabilityData, GenericError } from '../../PresentationalComponents/EmptyStates/EmptyStates';
import DownloadReport from '../../../Helpers/DownloadReport';
import CvePairStatusModal from '../Modals/CvePairStatusModal';
import SystemCveTableToolbar from './SystemCveTableToolbar';

export const CVETableContext = createContext({});

export const SystemCVEs = ({ intl, entity, location, history }) => {
    const dispatch = useDispatch();
    const [StatusModal, setStatusModal] = useState(() => () => null);
    const systemCVEs = useSelector(({ SystemCvesStore }) => SystemCvesStore.cveList);
    const parameters = useSelector(({ SystemCvesStore }) => SystemCvesStore.parameters);
    const selectedCves = useSelector(({ SystemCvesStore }) => SystemCvesStore.selectedCves);
    const openedCves = useSelector(({ SystemCvesStore }) => SystemCvesStore.openedCves);
    const expandCveDescription = useSelector(({ SystemCvesStore }) => SystemCvesStore.expandCveDescription);
    const cves =  useMemo(() => createCveListBySystem(entity, systemCVEs), [systemCVEs]);

    const urlParameters = qs.parse(location.search);

    useEffect(() =>{
        !parameters.isFirstMount && dispatch(fetchCveListBySystem({ ...parameters, system: entity }));
    }, [parameters, dispatch]);

    const createUrlParams = allParams => {
        const params = { ...urlParameters, ...allParams };
        const allowedParams = [
            'cvss_filter',
            'publish_date',
            'filter',
            'limit',
            'offset',
            'page',
            'page_size',
            'sort',
            'impact',
            'business_risk_id',
            'status_id',
            'security_rule'
        ];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);
        history.push('?' + queryString);
    };

    const downloadReport = format => {
        const params = { ...parameters, system: entity };
        DownloadReport.exec(fetchCveListBySystem, params, format, 'system-cves');
    };

    const processError = error => {
        const { status } = error;
        const statusCode = parseInt(status);
        if (statusCode === 404 && entity) {
            return EmptyVulnerabilityData;
        } else {
            return GenericError;
        }
    };

    const apply = (config = {}) => {
        if (Object.prototype.hasOwnProperty.call(config, 'cvss_filter')) {
            let cvssEntry = CVSSOptions.find(item => item.value === config.cvss_filter);

            if (typeof cvssEntry === 'undefined' && typeof config.cvss_filter !== 'undefined') {
                let values = config.cvss_filter.split(/[^0-9]+/).filter(item => parseFloat(item));
                cvssEntry = { from: values[0], to: values[1] };
            } else if (typeof cvssEntry === 'undefined' && typeof config.cvss_filter === 'undefined') {
                cvssEntry = { from: undefined, to: undefined };
            }

            config.cvss_from = cvssEntry.from;
            config.cvss_to = cvssEntry.to;
        }

        if (Object.prototype.hasOwnProperty.call(config, 'publish_date')) {
            let publicEntry = PublicDateOptions.find(item => item.value === config.publish_date);

            if (typeof publicEntry !== 'undefined') {
                config.public_from = publicEntry.from && publicEntry.from.format('YYYY-MM-DD');
                config.public_to = publicEntry.to && publicEntry.to.format('YYYY-MM-DD');
            } else {
                config.public_from = undefined;
                config.public_to = undefined;
                config.publish_date = undefined;
            }
        }

        createUrlParams(config);
        dispatch(changeSystemCVEsParameters(config));
    };

    useEffect(() => {
        apply({ ...parameters, ...urlParameters, page: 1, isFirstMount: false, sort: '-public_date' });
    }, []);

    const showStatusModal = cvesList => {
        let hasDifferentStatus;
        if (cvesList.length > 1) {
            const selectedCves = Array.from(cves.data.filter(cve => cvesList.some(element => element.id === cve.id)));

            hasDifferentStatus = selectedCves.some(element => {
                return selectedCves.filter(cve => cve.status_id === element.status_id).length > 1 ? false : true;
            });
        }

        setStatusModal(()=> () =>
            (<CvePairStatusModal
                cves={cvesList}
                updateRef={() => { apply(parameters); }}
                inventories={[{ id: entity }]}
                hasDifferentStatus={hasDifferentStatus}
                type={'systemDetail'}
            />)
        );
    };

    const handleCveSelect = (iSelected, payload) => {
        dispatch(selectSystemCve(payload));
    };

    const handleCveOpen = (isOpen, cves, expandCveDescription) => {
        dispatch(expandSystemCve({ isOpen, cves, expandCveDescription }));
    };

    if (!systemCVEs.errors) {
        return (
            <Fragment>
                <CVETableContext.Provider
                    value={{
                        cves,
                        parameters,
                        selectedCves,
                        openedCves,
                        expandCveDescription,
                        methods: {
                            apply,
                            downloadReport,
                            selectCves: handleCveSelect,
                            openCves: handleCveOpen,
                            showStatusModal,
                            fetchResource: params => fetchCveListBySystem({ ...params, system: entity })
                        }
                    }}
                >
                    <StatusModal />

                    <Stack>
                        <StackItem>
                            <TextContent>
                                <Text component={TextVariants.h2}>
                                    {intl.formatMessage(messages.systemCvesTableHeader)}
                                </Text>
                            </TextContent>
                        </StackItem>
                        <StackItem>
                            <SystemCveTableToolbar showRemediationButton entity={entity} />
                        </StackItem>
                        <StackItem>
                            <SystemCveTable header={SYSTEM_DETAILS_HEADER} entity={entity} />
                        </StackItem>
                    </Stack>
                </CVETableContext.Provider>
            </Fragment>);
    }
    else {
        return processError(systemCVEs.errors);
    }

};

SystemCVEs.propTypes = {
    entity: propTypes.string,
    cveList: propTypes.any,
    fetchData: propTypes.func,
    history: propTypes.object,
    location: propTypes.object,
    intl: propTypes.any
};

export const ConnectedSystemCves = withRouter(
    injectIntl(SystemCVEs)
);

const TranslateSystemCves = ({ customItnlProvider, ...props }) => {
    const {
        Wrapper,
        intlProps
    } = customItnlProvider ? {
        Wrapper: IntlProvider,
        intProps: {
            locale: navigator.language.slice(0, 2),
            messages
        }
    } : {
        wrapper: Fragment,
        intlProps: {}
    };
    return <Wrapper {...intlProps} >
        <ConnectedSystemCves { ...props } />
    </Wrapper>;
};

TranslateSystemCves.propTypes = {
    customItnlProvider: propTypes.bool
};

TranslateSystemCves.defaultProps = {
    customItnlProvider: false
};

export default TranslateSystemCves;
