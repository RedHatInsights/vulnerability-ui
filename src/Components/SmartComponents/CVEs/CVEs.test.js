import CVEs from './CVEs';
import { initialState } from '../../../Store/Reducers/CVEsStore'
import configureStore from 'redux-mock-store';
import { useSelector } from 'react-redux';
import DownloadReport from '../../../Helpers/DownloadReport';
import { CVES_DEFAULT_FILTERS } from '../../../Helpers/constants';
import { render, screen, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useHybridSystemFilterFlag } from '../../../Helpers/Hooks';
import TestWrapper from '../../../Utilities/TestWrapper';
import { cveState } from '../mockData.fixtures';
import '@testing-library/jest-dom';

import '@testing-library/jest-dom';

jest.mock('../../../Helpers/Hooks', () => ({
    ...jest.requireActual('../../../Helpers/Hooks'),
    useRbac: () => [[true, true, true, true], false],
    useHybridSystemFilterFlag: jest.fn(() => false)
}));

jest.mock('../../../Store/Actions/Actions', () => ({
    ...jest.requireActual('../../../Store/Actions/Actions'),
    fetchCveListByAccount: () => ({
        type: 'FETCH_CVE_LIST',
        payload: new Promise(() => {})
    })
}));

jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

const customMiddleWare = store => next => action => {
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: cveState });
    });
    next(action);
}

const mockStore = configureStore([customMiddleWare]);
const store = mockStore(initialState);

beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: initialState });
    });
});

afterEach(() => {
    useSelector.mockClear();
});

describe('CVEs', () => {
    it('Should dispatch CHANGE_CVE_LIST_PARAMETERS and FETCH_CVE_LIST only once on load', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );
        const dispatchedActions = store.getActions();

        expect(dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'FETCH_CVE_LIST')).toHaveLength(1);
    });

    it('Should clear store on unmount', () => {
        const { unmount } = render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        unmount();
        const dispatchedActions = store.getActions();
        setTimeout(() => {
            expect(dispatchedActions.includes('CLEAR_CVES_STORE')).toBeVisible();
        })
    });

    it('Should generate error', () => {
        const customMiddleWareErrors = store => next => action => {
            useSelector.mockImplementation(callback => {
                return callback({
                    CVEsStore: {
                        ...initialState,
                        cveList: { isLoading: false, payload: { errors: true, meta: {}, data: [] } }
                    }
                });
            });
            next(action);
        }

        const mockStoreErrors = configureStore([customMiddleWareErrors]);
        const storeForErrors = mockStoreErrors(initialState);

        render(
            <TestWrapper store={ storeForErrors }>
                <CVEs />
            </TestWrapper>
        );
        expect(screen.getByRole('heading', { name: 'Something went wrong' })).toBeVisible();
    });

    it.skip('Should wrap with context provider of shape', () => {
        const { container } = render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        expect(context).toEqual(
            {
                cves: {
                    data: expect.any(Array),
                    meta: expect.any(Object),
                    isLoading: false,
                    errors: undefined
                },
                params: {
                    sort: '-public_date',
                    ...CVES_DEFAULT_FILTERS
                },
                selectedCves: [],
                expandedRows: [],
                isAllExpanded: false,
                methods: {
                    apply: expect.any(Function),
                    downloadReport: expect.any(Function),
                    selectCves: expect.any(Function),
                    setColumnManagementModalOpen: expect.any(Function),
                    showBusinessRiskModal: expect.any(Function),
                    showStatusModal: expect.any(Function),
                    openCves: expect.any(Function)
                }
            }
        );
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );
        userEvent.click(screen.getByRole('checkbox', { name: /select row 0/i }));
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual("CVE-2019-6454");
    });

    it('Should call Download exec with format and parameters', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        userEvent.click(screen.getByRole('button', { name: /export/i }));
        userEvent.click(screen.getByRole('menuitem', { name: 'Export to JSON' }));

        expect(DownloadReport.exec).toHaveBeenCalled();
    });

    it('Should display business risk modal', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        const row = screen.getByRole('row', {
            name: /details select row 0 cve\-2020\-0543 09 june 2020 moderate moderate 6\.5 1 not defined on\-hold not available/i
        });
          
        userEvent.click(within(row).getByRole('button', {
            name: /actions/i
        }));

        userEvent.click(screen.getByRole('menuitem', { name: /edit business risk/i }));

        expect(screen.getByRole('heading', {
            name: /edit business risk/i
        })).toBeVisible();
    });

    it('Should display status modal', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        const row = screen.getByRole('row', {
            name: /details select row 0 cve\-2020\-0543 09 june 2020 moderate moderate 6\.5 1 not defined on\-hold not available/i
        });
          
        userEvent.click(within(row).getByRole('button', {
            name: /actions/i
        }));

        userEvent.click(screen.getByRole('menuitem', { name: /edit status/i }));

        expect(screen.getByRole('heading', {
            name: /edit status/i
        })).toBeVisible();
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        userEvent.click(screen.getByRole('button', {
            name: /details/i
        }));

        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')[0].payload).toEqual(0);
    });

    it.skip('Should dispatch changeParameters action on apply method call with provided parameters', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply({ test: 'testString' });
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({ test: 'testString' });
        expect(action).toHaveLength(2);
    });

    it.skip('Should apply method set filterParams to default {} when no parameter supplied', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply();
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({});
        expect(action).toHaveLength(2);
    });

});

describe('CVEs RTL', () => {
    it('Should show extended Systems filter when edge parity feature is disabled', async () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        userEvent.click(screen.getByRole('button', {
            name: /conditional filter/i
        }));

        userEvent.click(screen.getByText(
            'Systems',
            { selector: '.pf-c-dropdown__menu-item' }
        ));

        userEvent.click(screen.getByText(
            'Filter by systems',
            { selector: '.pf-c-select__toggle-text' }
        ));

        expect(screen.getByText('1 or more')).toBeVisible();
        expect(screen.getByText('None')).toBeVisible();
    });

    it('Should show extended Systems filter when edge parity feature is enabled', async () => {
        useHybridSystemFilterFlag.mockReturnValue(true);
        render(<TestWrapper store={ store }> 
            <CVEs />
        </TestWrapper>);

        userEvent.click(screen.getByRole('button', {
            name: /conditional filter/i
        }));
        
        userEvent.click(screen.getByText(
            'Systems',
            { selector: '.pf-c-dropdown__menu-item' }
        ));

        userEvent.click(screen.getByText(
            'Filter by systems',
            { selector: '.pf-c-select__toggle-text' }
        ));

        expect(screen.getByText('1 or more Conventional (RPM-DNF)')).toBeVisible();
        expect(screen.getByText('1 or more Immutable (OSTree)')).toBeVisible();
        expect(screen.getByText('None')).toBeVisible();
    });
});

