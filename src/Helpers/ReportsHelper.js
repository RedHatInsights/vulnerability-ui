import React from 'react';
import { CVE_REPORT_FILTERS,
    PUBLIC_DATE_OPTIONS,
    RULE_PRESENCE_OPTIONS,
    DEFAULT_FILTER_DATA,
    PDF_REPORT_PER_PAGE,
    KNOWN_EXPLOIT_FILTER_OPTIONS
} from './constants';
import { formatDate } from './MiscHelper';
import { intl } from '../Utilities/IntlProvider';
import { Text } from '@react-pdf/renderer';
import styles from '../Components/SmartComponents/Reports/Common/styles';

export const buildFilters = filterData => {
    let newValues = {};
    Object.entries(filterData).forEach(([key, value]) => {
        // if the filters value is default don't include it
        if (DEFAULT_FILTER_DATA[key] === value
            || value.length === 0
            || (Array.isArray(value) && value.length > 0 && value.length === CVE_REPORT_FILTERS[key].items?.length)
            || (key === 'cvss_filter' && value.from === 0 && value.to === 10)) {
            return;
        }

        newValues[key] = { filter: CVE_REPORT_FILTERS[key].title };

        switch (key) {
            case 'status_id':
            case 'business_risk_id':
            case 'impact': {
                const wordArray = value && Array.from(value).map(subvalue =>
                    CVE_REPORT_FILTERS[key].items.find(val => val.value === subvalue)
                        ? CVE_REPORT_FILTERS[key].items.find(val => val.value === subvalue).label
                        : '');
                newValues[key].values = wordArray.join(', ');
                break;
            }

            case 'publish_date':
                newValues[key].values = PUBLIC_DATE_OPTIONS.find(val => val.value === value).timespan_label;
                break;

            case 'rule_presence':
                newValues[key].values = value.map(
                    checkedValue => RULE_PRESENCE_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;
            case 'known_exploit':
                newValues[key].values = value.map(
                    checkedValue => KNOWN_EXPLOIT_FILTER_OPTIONS.find(({ value }) => value === checkedValue).label
                ).join(', ');
                break;

            case 'cvss_filter':
                newValues[key].values = value.from.toFixed(1) + ' - ' + value.to.toFixed(1);
                break;

            default:
                newValues[key].values = value;
        }
    });

    return newValues;
};

export function constructFilterParameters(filterParams) {
    // construct publish date
    let publicEntry = PUBLIC_DATE_OPTIONS.find(item => item.value === filterParams.publish_date);
    let from = undefined;
    let to = undefined;

    if (typeof publicEntry !== 'undefined') {
        from = publicEntry.from && formatDate(publicEntry.from);
        to = publicEntry.to && formatDate(publicEntry.to);
    }

    // FIXME contruct should be dynamic
    // construct rest of params
    let newParams =  {
        status_id: filterParams.status_id.toString(),
        business_risk_id: filterParams.business_risk_id.toString(),
        impact: filterParams.impact.toString(),
        cvss_from: filterParams.cvss_filter.from,
        cvss_to: filterParams.cvss_filter.to,
        publish_date: filterParams.publish_date,
        public_from: from,
        public_to: to,
        rule_presence: filterParams.rule_presence.toString(),
        known_exploit: filterParams.known_exploit.toString()
    };

    return newParams;
}

export const intlFormatWithBold = (msg, params) => {
    return intl.formatMessage(msg, { ...params, b: (...chunks) => <Text style={styles.bold}>{chunks}</Text> });
};

export const firstPagePDFLength = (data, params) => {
    let { firstPageWithNote, firstPageWithoutNote } = PDF_REPORT_PER_PAGE;
    return data.userNotes || params.rule_presence === 'true' ? firstPageWithNote : firstPageWithoutNote;
};

export const otherPagesPDFLength = (data, params) => {
    let { otherPages, otherPagesWithLabels } = PDF_REPORT_PER_PAGE;

    return params.rule_presence === 'true' ? otherPagesWithLabels : otherPages;
};
