import React from 'react';
import '@testing-library/jest-dom';
import { screen, waitFor } from '@testing-library/react';
import { ComponentWithContext } from './TestingUtilities';
import { render } from '@testing-library/react';
import { InsightsElement } from "./VulnerabilityRoutes";
import useFeatureFlag from './useFeatureFlag';
import { getSystems, checkEdgePresence } from '../Helpers/APIHelper';
import '@testing-library/jest-dom';

jest.mock('./useFeatureFlag', () => ({
    ...jest.requireActual('./useFeatureFlag'),
    __esModule: true,
    default: jest.fn(() => false)
}))
 
jest.mock('@redhat-cloud-services/frontend-components/AsyncComponent', () => ({
    __esModule: true,
    default: jest.fn((props) => (
        <div {...props} aria-label="Zero state">
            AsyncComponent
        </div>
    )),
}));

jest.mock('../Helpers/APIHelper', () => ({
    ...jest.requireActual('../Helpers/APIHelper'),
    getSystems: jest.fn(() => Promise.resolve({ meta: { total_items: 1 } })),
    checkEdgePresence: jest.fn(() => Promise.resolve(true)),
}));

const TestElement = (props) => <div {...props} />;

afterEach(() => {
    jest.clearAllMocks();
});
describe('VulnerabilityRoutes', () => {
    describe('InsightsElement', () => {
        it('Should show loading state while account stats are being loaded', () =>{
            render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);

            expect(
                screen.getByLabelText('Spinner')
            ).toBeVisible();
        });

        describe(('edge parit disabled'), () => {
            it('Should show zero state when there is no conventional, regardless of edge system', async () =>{
                getSystems.mockReturnValueOnce(Promise.resolve({ meta: { total_items: 0 } }));
                render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);
    
                await waitFor(() => {
                    expect(
                        screen.getByLabelText('Zero state')
                    ).toBeVisible();
                });
            });
            it('Should element when there is a conventional system, regardless of edge system', async () =>{
                render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);
    
                await waitFor(() => {
                    expect(
                        screen.getByLabelText('Insights element')
                    ).toBeVisible();
                });
            });
        });

        describe(('edge parit enabled'), () => {
            beforeEach(() => {
                useFeatureFlag.mockReturnValue(true);
            });
            it('Should show zero state when there is no conventional and edge systems', async () =>{
                getSystems.mockReturnValueOnce(Promise.resolve({ meta: { total_items: 0 } }));
                checkEdgePresence.mockReturnValueOnce(Promise.resolve(false));
                render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);
    
                await waitFor(() => {
                    expect(
                        screen.getByLabelText('Zero state')
                    ).toBeVisible();
                });
            });
            it('Should element when there is no conventional, but there is an edge systems', async () =>{
                getSystems.mockReturnValueOnce(Promise.resolve({ meta: { total_items: 0 } }));
                render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);

                await waitFor(() => {
                    expect(
                        screen.getByLabelText('Insights element')
                    ).toBeVisible();
                });
            });
            it('Should element when there is conventional, but there is no edge systems', async () =>{
                getSystems.mockReturnValueOnce(Promise.resolve({ meta: { total_items: 1 } }));
                render(<ComponentWithContext>
                    <InsightsElement element={TestElement} />
                </ComponentWithContext>);

                await waitFor(() => {
                    expect(
                        screen.getByLabelText('Insights element')
                    ).toBeVisible();
                });
            });
        })


    });
})