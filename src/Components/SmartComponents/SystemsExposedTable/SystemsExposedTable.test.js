import SystemsExposedTable from './SystemsExposedTable';
import { mountWithIntl } from '../../../Helpers/MiscHelper';
import { BrowserRouter as Router } from 'react-router-dom';
import toJson from 'enzyme-to-json';
import { initialState } from '../../../Store/Reducers/CVEDetailsPageStore'
import { Provider, useSelector } from 'react-redux';
import configureStore from 'redux-mock-store';
import React from 'react';
import { act } from "react-dom/test-utils";
import DownloadReport from '../../../Helpers/DownloadReport';

jest.spyOn(React, 'createRef').mockReturnValueOnce({ current: false });
jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

const state = {
    ...initialState,
};

const customMiddleWare = store => next => action => {
    useSelector.mockImplementation(callback => {
        return callback({ CVEDetailsPageStore: state });
    });
    React.createRef.mockImplementation(() => ({current: { onRefreshData: () => {}   } }));
    next(action);
}
const mockStore = configureStore([customMiddleWare]);
let store = mockStore(initialState);

window.insights = { 
    loadInventory:  jest.fn(() => Promise.resolve({
        inventoryConnector: (args) => { 
            const InventoryTable = () => <div>A mock passed!</div>;
            return ({ InventoryTable });
        },
        mergeWithEntities: () => {},
        mergeWithDetail: () => {}
    }))
}; 

let wrapper;
beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ CVEDetailsPageStore: initialState });
    });
    
    wrapper = mountWithIntl(
        <Provider store={store}>
            <Router>
                <SystemsExposedTable
                    cve={'testCveName'}
                    filterRuleValues={[{}]}
                    cveStatusDetails={{    
                        id: 'testCveName',
                        status_id: 1,
                        justification: 'testJustification'
                    }}
                    methods={{ showStatusModal: jest.fn() }}
                />
            </Router>
        </Provider>
    );
});

afterEach(() => {
    useSelector.mockClear();
});

describe('SystemsExposedPage', () => {
    it('Should clear store on unmount', () => {
        wrapper.unmount();
        const dispatchedActions = store.getActions();
        setTimeout(() => {
            expect(dispatchedActions.filter(item => item.type === 'CLEAR_CVE_STORE')).toHaveLength(1);
            expect(dispatchedActions.filter(item => item.type === 'CLEAR_INVENTORY_STORE')).toHaveLength(1);
        })
    });

    it('Should dispatch FETCH_AFFECTED_SYSTEMS_BY_CVE only once on load', () => {        
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'FETCH_AFFECTED_SYSTEMS_BY_CVE')).toHaveLength(1);
    });

    it('Should update inventory', () => {
        const testObj = { page: 2, per_page: 2}
        wrapper.update(); 
        act( () => wrapper.find('BaseInvTable').props().onRefresh(testObj)); 
        const dispatchedActions = store.getActions();
        expect(dispatchedActions[2]).toEqual({
            type: 'CHANGE_EXPOSED_SYSTEMS_PARAMETERS',
            payload: { page: 2, page_size: 2 }
        });
    });
});