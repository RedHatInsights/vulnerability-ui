import { Table, TableBody, TableHeader } from '@patternfly/react-table';
import { SkeletonTable, TableToolbar } from '@redhat-cloud-services/frontend-components';
import propTypes from 'prop-types';
import React, { Component, Fragment } from 'react';
import { connect } from 'react-redux';
import { EmptyCVEList, EmptyCVEListForSystem, FilterNotFoundForCVE } from '../../../Helpers/constants';
import { createSortBy, handleSortColumn } from '../../../Helpers/MiscHelper';
import { expandCve } from '../../../Store/Actions/Actions';
import PaginationWrapper from '../../PresentationalComponents/PaginationWrapper/PaginationWrapper';
import { CVETableContext } from './VulnerabilitiesCves';

class VulnerabilitiesTableWithContext extends Component {
    static propTypes = {
        context: propTypes.any,
        header: propTypes.array,
        entity: propTypes.object,
        openCve: propTypes.func
    };

    noCves = () => {
        const { entity, context } = this.props;
        const { cves } = context;
        const filterFields = ['filter', 'cvss_from', 'cvss_to', 'public_from', 'public_to', 'impact', 'status_id'].filter(
            item => cves.meta.hasOwnProperty(item) && cves.meta[item]
        );
        if (filterFields.length !== 0) {
            return FilterNotFoundForCVE;
        } else if (entity) {
            return EmptyCVEListForSystem;
        } else if (cves.data.length === 0) {
            return EmptyCVEList;
        }
    };

    handleOnCollapse = (event, rowKey, isOpen) => {
        const { rows } = this.state;
        /**
         * Please do not use rowKey as row index for more complex tables.
         * Rather use some kind of identifier like ID passed with each row.
         */
        rows[rowKey].isOpen = isOpen;
        this.setState({
            rows
        });
    };

    handleOnSelect = (event, isSelected, rowId) => {
        const { context } = this.props;
        const { cves, methods } = context;
        const cveName = cves.data[rowId] && cves.data[rowId].id;
        methods.selectCves(isSelected, cveName);
    };

    handleBusinessRiskToggle = () => {
        this.setState(({ isBusinessRiskOpen }) => ({
            isBusinessRiskOpen: !isBusinessRiskOpen
        }));
    };

    render() {
        const { context, header } = this.props;
        const { cves, methods } = context;
        const actions = [
            {
                title: 'Edit business risk',
                onClick: (event, rowId, rowData) =>
                    methods.showBusinessRiskModal([
                        {
                            id: rowData.id,
                            business_risk_id: rowData.business_risk_id,
                            justification: rowData.business_risk_justification
                        }
                    ])
            },
            {
                title: 'Edit status',
                onClick: (event, rowId, rowData) =>
                    methods.showStatusModal([
                        {
                            id: rowData.id,
                            status_id: rowData.status_id,
                            justification: rowData.status_justification
                        }
                    ])
            }
        ];
        return (
            <Fragment>
                {!cves.isLoading ? (
                    <Fragment>
                        <Table
                            aria-label={'Vulnerability CVE table'}
                            onSelect={this.handleOnSelect}
                            cells={header}
                            rows={cves.data}
                            onCollapse={(event, rowKey) => this.props.openCve(rowKey)}
                            actions={actions}
                            sortBy={createSortBy([{ key: 'collapse' }, { key: 'checkbox' }, ...header], cves.meta.sort)}
                            onSort={(event, key, direction) =>
                                handleSortColumn(
                                    key,
                                    direction,
                                    [{ key: 'collapse' }, { key: 'checkbox' }, ...header],
                                    cves.meta.sort,
                                    methods.apply
                                )
                            }
                            gridBreakPoint={'grid-lg'}
                        >
                            {(!cves.isLoading && cves.data.length === 0 && this.noCves()) || (
                                <Fragment>
                                    <TableHeader />
                                    <TableBody />
                                </Fragment>
                            )}
                        </Table>
                        <TableToolbar>
                            <PaginationWrapper variant="bottom" meta={cves.meta} apply={methods.apply} />
                        </TableToolbar>
                    </Fragment>
                ) : (
                    <SkeletonTable colSize={6} rowSize={20} />
                )}
            </Fragment>
        );
    }
}

const mapDispatchToProps = dispatch => {
    return {
        openCve: params => dispatch(expandCve(params))
    };
};

const VulnerabilitiesTable = props => (
    <CVETableContext.Consumer>
        {context => <VulnerabilitiesTableWithContext context={context} {...props} />}
    </CVETableContext.Consumer>
);
export default connect(
    null,
    mapDispatchToProps
)(VulnerabilitiesTable);
