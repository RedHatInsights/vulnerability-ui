
import React, { useState, useEffect } from 'react';
import propTypes from 'prop-types';
import { useIntl } from 'react-intl';
import { DownloadButton } from '@redhat-cloud-services/frontend-components-pdf-generator';
import { getCveListByAccount } from '../../../Helpers/APIHelper';
import { chunkArray } from '../../../Helpers/MiscHelper';
import { firstPagePDFLength, otherPagesPDFLength } from '../../../Helpers/ReportsHelper';
import messages from '../../../Messages';
import firstPagePDF from './Common/firstPagePDF';
import tablePage from './Common/tablePage';
import FooterPDF from './Common/FooterPDF';
import DownloadReport from '../../../Helpers/DownloadReport';
import { STATUS_OPTIONS, BUSINESS_RISK_OPTIONS, impactList } from '../../../Helpers/constants';
import { useNotification } from '../../../Helpers/Hooks';

const DownloadCVEsReport = ({
    filters,
    params,
    reportData = {},
    buttonProps,
    isReportDynamic = false,
    label,
    ...props
}) => {
    const intl = useIntl();
    const [loading, setLoading] = useState(false);
    const [hasRule, setSecurityRulesPresent] = useState(false);
    const [hasExploit, setExploit] = useState(false);
    const [addNotification, clearNotifications] = useNotification();

    useEffect(() => {
        setLoading(true);
        addNotification({ msg: intl.formatMessage(messages.notificationReportDownloadStart) });
    }, []);

    const otherPagesPDF = data => chunkArray(
        data,
        otherPagesPDFLength(reportData, params),
        (total, { attributes }) => total + (attributes.rules.length > 0)
    );

    const cvesFetch = async () => {
        let cves;
        let meta;

        try {
            ({ data: cves, meta } = await getCveListByAccount({
                ...params,
                ...DownloadReport.defaultParams,
                sort: params.sort || '-cvss_score',
                affecting: 'true'
            }));
        }
        catch {
            clearNotifications();
            addNotification({
                variant: 'danger',
                autoDismiss: false,
                msg: intl.formatMessage(messages.notificationReportDownloadFailureTitle),
                description: intl.formatMessage(messages.notificationReportDownloadFailureBody)
            });

            return [];
        }

        let user;
        if (reportData && reportData.userNotes) {
            user = await insights.chrome.auth.getUser();
        }

        const processData = (cves, meta) => {
            meta.knownExploitCount = cves.filter(({ attributes }) => attributes.known_exploit === true).length;

            return cves.map(cve => {
                if (!meta.hasRule) {
                    meta.hasRule = cve.attributes.rules.length > 0;
                }

                return {
                    ...cve,
                    attributes: {
                        ...cve.attributes,
                        status: STATUS_OPTIONS.find(item =>
                            item.value === cve.attributes.status_id.toString()).label,
                        business_risk: BUSINESS_RISK_OPTIONS.find(item =>
                            item.value === cve.attributes.business_risk_id.toString()).label,
                        impact: impactList[cve.attributes.impact]?.title || intl.formatMessage(messages.impactListUnknown),
                        cvss_score: parseFloat(cve.attributes.cvss3_score || cve.attributes.cvss2_score).toFixed(1)
                    }
                };
            });
        };

        const data = processData(cves, meta);

        setSecurityRulesPresent(() => {
            return isReportDynamic ? meta.hasRule && reportData && reportData.header?.includes('rule_presence') : meta.hasRule;
        });

        setExploit(() => {
            return isReportDynamic
                ? meta.knownExploitCount > 0 && reportData && reportData.header?.includes('known_exploit')
                : meta.knownExploitCount > 0;
        });

        const firstPage = firstPagePDF({
            data: data.splice(0, firstPagePDFLength(reportData, params)),
            meta,
            filters,
            intl,
            isReportDynamic,
            reportData,
            user,
            type: 'cves' // FIXME: firstPagePDF should be more abstract
        });

        const otherPages = otherPagesPDF(data);

        setLoading(false);

        clearNotifications();
        addNotification({ variant: 'success', msg: intl.formatMessage(messages.notificationReportDownloadSuccess) });

        return [
            firstPage,
            ...otherPages.map((cvePage, index) =>
                tablePage({
                    data: cvePage,
                    page: index,
                    intl,
                    header: reportData && reportData.header,
                    type: 'cves', // FIXME: same for tablePage
                    isReportDynamic
                })
            )
        ];
    };

    return (
        <div>
            <DownloadButton
                fallback={null}
                orientation={'landscape'}
                size={'A4'}
                type={''}
                fileName={`${DownloadReport.filename(isReportDynamic ? 'reports' : '')}.pdf`}
                buttonProps={{ component: 'button', ...buttonProps }}
                asyncFunction={cvesFetch}
                allPagesHaveTitle={false}
                footer={<FooterPDF intl={intl} hasRule={hasRule} hasExploit={hasExploit} />}
                reportName={
                    isReportDynamic
                        ? reportData.reportTitle
                        : intl.formatMessage(messages.cvePDFReportName)
                }
                label={
                    loading
                        ? intl.formatMessage(messages.loading)
                        : intl.formatMessage(label)
                }
                {...props}
            />
        </div>
    );
};

DownloadCVEsReport.defaultProps = {
    label: messages.kebabExportAsPDF
};

DownloadCVEsReport.propTypes = {
    filters: propTypes.oneOfType([
        propTypes.array,
        propTypes.object
    ]),
    params: propTypes.object,
    reportData: propTypes.object,
    buttonProps: propTypes.object,
    label: propTypes.oneOfType([
        propTypes.array,
        propTypes.object
    ]),
    isReportDynamic: propTypes.bool
};

export default DownloadCVEsReport;
