import CVEs from './CVEs';
import { initialState } from '../../../Store/Reducers/CVEsStore'
import configureStore from 'redux-mock-store';
import { useSelector } from 'react-redux';
import DownloadReport from '../../../Helpers/DownloadReport';
import { CVES_DEFAULT_FILTERS } from '../../../Helpers/constants';
import { fireEvent, render, screen, waitFor, within } from '@testing-library/react';
import { useHybridSystemFilterFlag } from '../../../Helpers/Hooks';
import TestWrapper from '../../../Utilities/TestWrapper';
import { cveState } from '../mockData.fixtures';
import '@testing-library/jest-dom';
import { ComponentWithContext } from '../../../Utilities/TestingUtilities';

jest.mock('../../../Helpers/Hooks', () => ({
    ...jest.requireActual('../../../Helpers/Hooks'),
    useRbac: () => [[true, true, true, true], false],
    useHybridSystemFilterFlag: jest.fn(() => false)
}));

jest.mock('../../../Store/Actions/Actions', () => ({
    ...jest.requireActual('../../../Store/Actions/Actions'),
    fetchCveListByAccount: () => ({
        type: 'FETCH_CVE_LIST',
        payload: new Promise(() => {})
    })
}));

jest.mock("react-redux", () => ({
    ...jest.requireActual("react-redux"),
    useSelector: jest.fn()
}));

jest.mock("../../../Helpers/DownloadReport", () => ({
    ...jest.requireActual("../../../Helpers/DownloadReport"),
    exec: jest.fn()
}));

const mockStore = configureStore([]);
const store = mockStore(initialState);

beforeEach(() => {
    store.clearActions();
    useSelector.mockImplementation(callback => {
        return callback({ CVEsStore: cveState });
    });
});

describe('CVEs', () => {
    it('Should dispatch CHANGE_CVE_LIST_PARAMETERS and FETCH_CVE_LIST only once on load', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );
        const dispatchedActions = store.getActions();

        expect(dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'FETCH_CVE_LIST')).toHaveLength(1);
    });

    it('Should clear store on unmount', () => {
        const { unmount } = render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        unmount();
        const dispatchedActions = store.getActions();
        setTimeout(() => {
            expect(dispatchedActions.includes('CLEAR_CVES_STORE')).toBeVisible();
        })
    });

    it('Should generate error', () => {
        useSelector.mockImplementation(callback => {
            return callback({
                CVEsStore: {
                    ...initialState,
                    cveList: { isLoading: false, payload: { errors: true, meta: {}, data: [] } }
                }
            });
        });

        const mockStoreErrors = configureStore([]);
        const storeForErrors = mockStoreErrors();

        render(
            <TestWrapper store={ storeForErrors }>
                <CVEs />
            </TestWrapper>
        );

        expect(screen.getByRole('heading', { name: 'Something went wrong' })).toBeVisible();
    });

    it.skip('Should wrap with context provider of shape', () => {
        const { container } = render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        expect(context).toEqual(
            {
                cves: {
                    data: expect.any(Array),
                    meta: expect.any(Object),
                    isLoading: false,
                    errors: undefined
                },
                params: {
                    sort: '-public_date',
                    ...CVES_DEFAULT_FILTERS
                },
                selectedCves: [],
                expandedRows: [],
                isAllExpanded: false,
                methods: {
                    apply: expect.any(Function),
                    downloadReport: expect.any(Function),
                    selectCves: expect.any(Function),
                    setColumnManagementModalOpen: expect.any(Function),
                    showBusinessRiskModal: expect.any(Function),
                    showStatusModal: expect.any(Function),
                    openCves: expect.any(Function)
                }
            }
        );
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );
        fireEvent.click(screen.getByRole('checkbox', { name: /select row 0/i }));
        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'SELECT_CVE')[0].payload).toEqual("CVE-2019-6454");
    });

    it('Should call Download exec with format and parameters', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        fireEvent.click(screen.getByRole('button', { name: /export/i }));
        fireEvent.click(screen.getByRole('menuitem', { name: 'Export to JSON' }));

        expect(DownloadReport.exec).toHaveBeenCalled();
    });

    it('Should display business risk modal', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );
          
        fireEvent.click(screen.getByRole('button', {
            name: /kebab toggle/i
        }));

        fireEvent.click(screen.getByRole('menuitem', { name: /edit business risk/i }));

        expect(screen.getByRole('heading', {
            name: /edit business risk/i
        })).toBeVisible();
    });

    it('Should display status modal', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        fireEvent.click(screen.getByRole('button', {
            name: /kebab toggle/i
        }));

        fireEvent.click(screen.getByRole('menuitem', { name: /edit status/i }));

        expect(screen.getByRole('heading', {
            name: /edit status/i
        })).toBeVisible();
    });

    it('Should dispatch selectCve action on selecting (an) entity/entities', () => {
        render(
            <TestWrapper store={ store }>
                <CVEs />
            </TestWrapper>
        );

        fireEvent.click(screen.getByRole('button', {
            name: /details/i
        }));

        const dispatchedActions = store.getActions();
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')).toHaveLength(1);
        expect(dispatchedActions.filter(item => item.type === 'EXPAND_CVE')[0].payload).toEqual(0);
    });

    it.skip('Should dispatch changeParameters action on apply method call with provided parameters', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply({ test: 'testString' });
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({ test: 'testString' });
        expect(action).toHaveLength(2);
    });

    it.skip('Should apply method set filterParams to default {} when no parameter supplied', async () => {
        const { context } = wrapper.find('CVEsTableWithContext').props();
        context.methods.apply();
        const dispatchedActions = store.getActions();
        const action = dispatchedActions.filter(item => item.type === 'CHANGE_CVE_LIST_PARAMETERS');

        expect(action[1].payload).toEqual({});
        expect(action).toHaveLength(2);
    });

});

describe('CVEs default filters are enabled, no other filters are added in the URL', () => {
    it('Should show extended Systems filter when edge parity feature is disabled', async () => {
        render(
            <ComponentWithContext store={ store } renderOptions={{ initialEntries: ['?affecting=rpmdnf%2Cedge&advisory_available=true']}}>
                <CVEs />
            </ComponentWithContext>
        );

        fireEvent.click(screen.getByRole('button', {
            name: /conditional filter/i
        }));

        fireEvent.click(screen.getByRole('menuitem', {
            name: /systems/i
        }));

        fireEvent.click(screen.getByRole('button', {
            name: /options menu/i
        }));

        expect(screen.getByText(/1 or more/i)).toBeInTheDocument();
        expect(screen.getByText(/none/i)).toBeInTheDocument();
    });

    it('Should show extended Systems filter when edge parity feature is enabled', async () => {
        useHybridSystemFilterFlag.mockReturnValue(true);
        render(<ComponentWithContext store={ store } renderOptions={{ initialEntries: ['?affecting=rpmdnf%2Cedge&advisory_available=true']}}>
            <CVEs />
        </ComponentWithContext>);

        fireEvent.click(screen.getByRole('button', {
            name: /conditional filter/i
        }));
        
        fireEvent.click(screen.getByRole('menuitem', {
            name: /systems/i
        }));

        fireEvent.click(screen.getByRole('button', {
            name: /options menu/i
        }));

        expect(screen.getByText('1 or more Conventional (RPM-DNF)')).toBeInTheDocument();
        expect(screen.getByText('1 or more Immutable (OSTree)')).toBeInTheDocument();
        expect(screen.getByText('None')).toBeInTheDocument();
    });
});

